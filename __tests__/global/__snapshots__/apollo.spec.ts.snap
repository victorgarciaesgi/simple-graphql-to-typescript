// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test methods generation from different sources Generates types correctly from graphql Analyst 1`] = `
"/* eslint-disable */
/* tslint-disable */
// @ts-nocheck
// *******************************************************
// *******************************************************
//
// GENERATED FILE, DO NOT MODIFY
//
// Made by Victor Garcia Â®
//
// https://github.com/victorgarciaesgi
// *******************************************************
// *******************************************************
// ðŸ’™

export type Maybe<T> = T | null;

export interface IQueryModel {
  Page?: Maybe<IPageModel>;
  /** Media query*/
  Media?: Maybe<IMediaModel>;
  /** Media Trend query*/
  MediaTrend?: Maybe<IMediaTrendModel>;
  /** Airing schedule query*/
  AiringSchedule?: Maybe<IAiringScheduleModel>;
  /** Character query*/
  Character?: Maybe<ICharacterModel>;
  /** Staff query*/
  Staff?: Maybe<IStaffModel>;
  /** Media list query*/
  MediaList?: Maybe<IMediaListModel>;
  /** Media list collection query, provides list pre-grouped by status & custom lists. User ID and Media Type arguments required.*/
  MediaListCollection?: Maybe<IMediaListCollectionModel>;
  /** Collection of all the possible media genres*/
  GenreCollection?: Maybe<string[]>;
  /** Collection of all the possible media tags*/
  MediaTagCollection?: Maybe<IMediaTagModel[]>;
  /** User query*/
  User?: Maybe<IUserModel>;
  /** Get the currently authenticated user*/
  Viewer?: Maybe<IUserModel>;
  /** Notification query*/
  Notification?: Maybe<INotificationUnionModel>;
  /** Studio query*/
  Studio?: Maybe<IStudioModel>;
  /** Review query*/
  Review?: Maybe<IReviewModel>;
  /** Activity query*/
  Activity?: Maybe<IActivityUnionModel>;
  /** Activity reply query*/
  ActivityReply?: Maybe<IActivityReplyModel>;
  /** Follow query*/
  Following?: Maybe<IUserModel>;
  /** Follow query*/
  Follower?: Maybe<IUserModel>;
  /** Thread query*/
  Thread?: Maybe<IThreadModel>;
  /** Comment query*/
  ThreadComment?: Maybe<IThreadCommentModel[]>;
  /** Recommendation query*/
  Recommendation?: Maybe<IRecommendationModel>;
  /** Like query*/
  Like?: Maybe<IUserModel>;
  /** Provide AniList markdown to be converted to html (Requires auth)*/
  Markdown?: Maybe<IParsedMarkdownModel>;
  AniChartUser?: Maybe<IAniChartUserModel>;
  /** Site statistics query*/
  SiteStatistics?: Maybe<ISiteStatisticsModel>;
}

/** Page of data */
export interface IPageModel {
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
  users?: Maybe<IUserModel[]>;
  media?: Maybe<IMediaModel[]>;
  characters?: Maybe<ICharacterModel[]>;
  staff?: Maybe<IStaffModel[]>;
  studios?: Maybe<IStudioModel[]>;
  mediaList?: Maybe<IMediaListModel[]>;
  airingSchedules?: Maybe<IAiringScheduleModel[]>;
  mediaTrends?: Maybe<IMediaTrendModel[]>;
  notifications?: Maybe<INotificationUnionModel[]>;
  followers?: Maybe<IUserModel[]>;
  following?: Maybe<IUserModel[]>;
  activities?: Maybe<IActivityUnionModel[]>;
  activityReplies?: Maybe<IActivityReplyModel[]>;
  threads?: Maybe<IThreadModel[]>;
  threadComments?: Maybe<IThreadCommentModel[]>;
  reviews?: Maybe<IReviewModel[]>;
  recommendations?: Maybe<IRecommendationModel[]>;
  likes?: Maybe<IUserModel[]>;
}

export interface IPageInfoModel {
  /** The total number of items*/
  total?: Maybe<number>;
  /** The count on a page*/
  perPage?: Maybe<number>;
  /** The current page*/
  currentPage?: Maybe<number>;
  /** The last page*/
  lastPage?: Maybe<number>;
  /** If there is another page*/
  hasNextPage?: Maybe<boolean>;
}

/** A user */
export interface IUserModel {
  /** The id of the user*/
  id: number;
  /** The name of the user*/
  name: string;
  /** The bio written by user (Markdown)*/
  about?: Maybe<string>;
  /** The user's avatar images*/
  avatar?: Maybe<IUserAvatarModel>;
  /** The user's banner images*/
  bannerImage?: Maybe<string>;
  /** If the authenticated user if following this user*/
  isFollowing?: Maybe<boolean>;
  /** If this user if following the authenticated user*/
  isFollower?: Maybe<boolean>;
  /** If the user is blocked by the authenticated user*/
  isBlocked?: Maybe<boolean>;
  bans?: Maybe<string>;
  /** The user's general options*/
  options?: Maybe<IUserOptionsModel>;
  /** The user's media list options*/
  mediaListOptions?: Maybe<IMediaListOptionsModel>;
  /** The users favourites*/
  favourites?: Maybe<IFavouritesModel>;
  /** The users anime & manga list statistics*/
  statistics?: Maybe<IUserStatisticTypesModel>;
  /** The number of unread notifications the user has*/
  unreadNotificationCount?: Maybe<number>;
  /** The url for the user page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The donation tier of the user*/
  donatorTier?: Maybe<number>;
  /** Custom donation badge text*/
  donatorBadge?: Maybe<string>;
  /** If the user is a moderator or data moderator*/
  moderatorStatus?: Maybe<string>;
  /** When the user's data was last updated*/
  updatedAt?: Maybe<number>;
  /** The user's statistics*/
  stats?: Maybe<IUserStatsModel>;
}

/** A user's avatars */
export interface IUserAvatarModel {
  /** The avatar of user at its largest size*/
  large?: Maybe<string>;
  /** The avatar of user at medium size*/
  medium?: Maybe<string>;
}

/** A user's general options */
export interface IUserOptionsModel {
  /** The language the user wants to see media titles in*/
  titleLanguage?: Maybe<IUserTitleLanguageModel>;
  /** Whether the user has enabled viewing of 18+ content*/
  displayAdultContent?: Maybe<boolean>;
  /** Whether the user receives notifications when a show they are watching aires*/
  airingNotifications?: Maybe<boolean>;
  /** Profile highlight color (blue, purple, pink, orange, red, green, gray)*/
  profileColor?: Maybe<string>;
  /** Notification options*/
  notificationOptions?: Maybe<INotificationOptionModel[]>;
}

/** Notification option */
export interface INotificationOptionModel {
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** Whether this type of notification is enabled*/
  enabled?: Maybe<boolean>;
}

/** A user's list options */
export interface IMediaListOptionsModel {
  /** The score format the user is using for media lists*/
  scoreFormat?: Maybe<IScoreFormatModel>;
  /** The default order list rows should be displayed in*/
  rowOrder?: Maybe<string>;
  /** (Site only) If the user should be using legacy css-supporting list versions*/
  useLegacyLists?: Maybe<boolean>;
  /** The user's anime list options*/
  animeList?: Maybe<IMediaListTypeOptionsModel>;
  /** The user's manga list options*/
  mangaList?: Maybe<IMediaListTypeOptionsModel>;
  /** The list theme options for both lists*/
  sharedTheme?: Maybe<string>;
  /** If the shared theme should be used instead of the individual list themes*/
  sharedThemeEnabled?: Maybe<boolean>;
}

/** A user's list options for anime or manga lists */
export interface IMediaListTypeOptionsModel {
  /** The order each list should be displayed in*/
  sectionOrder?: Maybe<string[]>;
  /** If the completed sections of the list should be separated by format*/
  splitCompletedSectionByFormat?: Maybe<boolean>;
  /** The list theme options*/
  theme?: Maybe<string>;
  /** The names of the user's custom lists*/
  customLists?: Maybe<string[]>;
  /** The names of the user's advanced scoring sections*/
  advancedScoring?: Maybe<string[]>;
  /** If advanced scoring is enabled*/
  advancedScoringEnabled?: Maybe<boolean>;
}

/** User's favourite anime, manga, characters, staff & studios */
export interface IFavouritesModel {
  /** Favourite anime*/
  anime?: Maybe<IMediaConnectionModel>;
  /** Favourite manga*/
  manga?: Maybe<IMediaConnectionModel>;
  /** Favourite characters*/
  characters?: Maybe<ICharacterConnectionModel>;
  /** Favourite staff*/
  staff?: Maybe<IStaffConnectionModel>;
  /** Favourite studios*/
  studios?: Maybe<IStudioConnectionModel>;
}

export interface IMediaConnectionModel {
  edges?: Maybe<IMediaEdgeModel[]>;
  nodes?: Maybe<IMediaModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Media connection edge */
export interface IMediaEdgeModel {
  node?: Maybe<IMediaModel>;
  /** The id of the connection*/
  id?: Maybe<number>;
  /** The type of relation to the parent model*/
  relationType?: Maybe<IMediaRelationModel>;
  /** If the studio is the main animation studio of the media (For Studio->MediaConnection field only)*/
  isMainStudio: boolean;
  /** The characters in the media voiced by the parent actor*/
  characters?: Maybe<ICharacterModel[]>;
  /** The characters role in the media*/
  characterRole?: Maybe<ICharacterRoleModel>;
  /** The role of the staff member in the production of the media*/
  staffRole?: Maybe<string>;
  /** The voice actors of the character*/
  voiceActors?: Maybe<IStaffModel[]>;
  /** The order the media should be displayed from the users favourites*/
  favouriteOrder?: Maybe<number>;
}

/** Anime or Manga */
export interface IMediaModel {
  /** The id of the media*/
  id: number;
  /** The mal id of the media*/
  idMal?: Maybe<number>;
  /** The official titles of the media in various languages*/
  title?: Maybe<IMediaTitleModel>;
  /** The type of the media; anime or manga*/
  type?: Maybe<IMediaTypeModel>;
  /** The format the media was released in*/
  format?: Maybe<IMediaFormatModel>;
  /** The current releasing status of the media*/
  status?: Maybe<IMediaStatusModel>;
  /** Short description of the media's story and characters*/
  description?: Maybe<string>;
  /** The first official release date of the media*/
  startDate?: Maybe<IFuzzyDateModel>;
  /** The last official release date of the media*/
  endDate?: Maybe<IFuzzyDateModel>;
  /** The season the media was initially released in*/
  season?: Maybe<IMediaSeasonModel>;
  /** The season year the media was initially released in*/
  seasonYear?: Maybe<number>;
  /** The year & season the media was initially released in*/
  seasonInt?: Maybe<number>;
  /** The amount of episodes the anime has when complete*/
  episodes?: Maybe<number>;
  /** The general length of each anime episode in minutes*/
  duration?: Maybe<number>;
  /** The amount of chapters the manga has when complete*/
  chapters?: Maybe<number>;
  /** The amount of volumes the manga has when complete*/
  volumes?: Maybe<number>;
  /** Where the media was created. (ISO 3166-1 alpha-2)*/
  countryOfOrigin?: Maybe<undefined>;
  /** If the media is officially licensed or a self-published doujin release*/
  isLicensed?: Maybe<boolean>;
  /** Source type the media was adapted from.*/
  source?: Maybe<IMediaSourceModel>;
  /** Official Twitter hashtags for the media*/
  hashtag?: Maybe<string>;
  /** Media trailer or advertisement*/
  trailer?: Maybe<IMediaTrailerModel>;
  /** When the media's data was last updated*/
  updatedAt?: Maybe<number>;
  /** The cover images of the media*/
  coverImage?: Maybe<IMediaCoverImageModel>;
  /** The banner image of the media*/
  bannerImage?: Maybe<string>;
  /** The genres of the media*/
  genres?: Maybe<string[]>;
  /** Alternative titles of the media*/
  synonyms?: Maybe<string[]>;
  /** A weighted average score of all the user's scores of the media*/
  averageScore?: Maybe<number>;
  /** Mean score of all the user's scores of the media*/
  meanScore?: Maybe<number>;
  /** The number of users with the media on their list*/
  popularity?: Maybe<number>;
  /** Locked media may not be added to lists our favorited. This may be due to the entry pending for deletion or other reasons.*/
  isLocked?: Maybe<boolean>;
  /** The amount of related activity in the past hour*/
  trending?: Maybe<number>;
  /** The amount of user's who have favourited the media*/
  favourites?: Maybe<number>;
  /** List of tags that describes elements and themes of the media*/
  tags?: Maybe<IMediaTagModel[]>;
  /** Other media in the same or connecting franchise*/
  relations?: Maybe<IMediaConnectionModel>;
  /** The characters in the media*/
  characters?: Maybe<ICharacterConnectionModel>;
  /** The staff who produced the media*/
  staff?: Maybe<IStaffConnectionModel>;
  /** The companies who produced the media*/
  studios?: Maybe<IStudioConnectionModel>;
  /** If the media is marked as favourite by the current authenticated user*/
  isFavourite: boolean;
  /** If the media is intended only for 18+ adult audiences*/
  isAdult?: Maybe<boolean>;
  /** The media's next episode airing schedule*/
  nextAiringEpisode?: Maybe<IAiringScheduleModel>;
  /** The media's entire airing schedule*/
  airingSchedule?: Maybe<IAiringScheduleConnectionModel>;
  /** The media's daily trend stats*/
  trends?: Maybe<IMediaTrendConnectionModel>;
  /** External links to another site related to the media*/
  externalLinks?: Maybe<IMediaExternalLinkModel[]>;
  /** Data and links to legal streaming episodes on external sites*/
  streamingEpisodes?: Maybe<IMediaStreamingEpisodeModel[]>;
  /** The ranking of the media in a particular time span and format compared to other media*/
  rankings?: Maybe<IMediaRankModel[]>;
  /** The authenticated user's media list entry for the media*/
  mediaListEntry?: Maybe<IMediaListModel>;
  /** User reviews of the media*/
  reviews?: Maybe<IReviewConnectionModel>;
  /** User recommendations for similar media*/
  recommendations?: Maybe<IRecommendationConnectionModel>;
  stats?: Maybe<IMediaStatsModel>;
  /** The url for the media page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** If the media should have forum thread automatically created for it on airing episode release*/
  autoCreateForumThread?: Maybe<boolean>;
  /** If the media is blocked from being recommended to/from*/
  isRecommendationBlocked?: Maybe<boolean>;
  /** Notes for site moderators*/
  modNotes?: Maybe<string>;
}

/** The official titles of the media in various languages */
export interface IMediaTitleModel {
  /** The romanization of the native language title*/
  romaji?: Maybe<string>;
  /** The official english title*/
  english?: Maybe<string>;
  /** Official title in it's native language*/
  native?: Maybe<string>;
  /** The currently authenticated users preferred title language. Default romaji for non-authenticated*/
  userPreferred?: Maybe<string>;
}

/** Date object that allows for incomplete date values (fuzzy) */
export interface IFuzzyDateModel {
  /** Numeric Year (2017)*/
  year?: Maybe<number>;
  /** Numeric Month (3)*/
  month?: Maybe<number>;
  /** Numeric Day (24)*/
  day?: Maybe<number>;
}

/** Media trailer or advertisement */
export interface IMediaTrailerModel {
  /** The trailer video id*/
  id?: Maybe<string>;
  /** The site the video is hosted by (Currently either youtube or dailymotion)*/
  site?: Maybe<string>;
  /** The url for the thumbnail image of the video*/
  thumbnail?: Maybe<string>;
}

export interface IMediaCoverImageModel {
  /** The cover image url of the media at its largest size. If this size isn't available, large will be provided instead.*/
  extraLarge?: Maybe<string>;
  /** The cover image url of the media at a large size*/
  large?: Maybe<string>;
  /** The cover image url of the media at medium size*/
  medium?: Maybe<string>;
  /** Average #hex color of cover image*/
  color?: Maybe<string>;
}

/** A tag that describes a theme or element of the media */
export interface IMediaTagModel {
  /** The id of the tag*/
  id: number;
  /** The name of the tag*/
  name: string;
  /** A general description of the tag*/
  description?: Maybe<string>;
  /** The categories of tags this tag belongs to*/
  category?: Maybe<string>;
  /** The relevance ranking of the tag out of the 100 for this media*/
  rank?: Maybe<number>;
  /** If the tag could be a spoiler for any media*/
  isGeneralSpoiler?: Maybe<boolean>;
  /** If the tag is a spoiler for this media*/
  isMediaSpoiler?: Maybe<boolean>;
  /** If the tag is only for adult 18+ media*/
  isAdult?: Maybe<boolean>;
}

export interface ICharacterConnectionModel {
  edges?: Maybe<ICharacterEdgeModel[]>;
  nodes?: Maybe<ICharacterModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Character connection edge */
export interface ICharacterEdgeModel {
  node?: Maybe<ICharacterModel>;
  /** The id of the connection*/
  id?: Maybe<number>;
  /** The characters role in the media*/
  role?: Maybe<ICharacterRoleModel>;
  /** The voice actors of the character*/
  voiceActors?: Maybe<IStaffModel[]>;
  /** The media the character is in*/
  media?: Maybe<IMediaModel[]>;
  /** The order the character should be displayed from the users favourites*/
  favouriteOrder?: Maybe<number>;
}

/** A character that features in an anime or manga */
export interface ICharacterModel {
  /** The id of the character*/
  id: number;
  /** The names of the character*/
  name?: Maybe<ICharacterNameModel>;
  /** Character images*/
  image?: Maybe<ICharacterImageModel>;
  /** A general description of the character*/
  description?: Maybe<string>;
  /** If the character is marked as favourite by the currently authenticated user*/
  isFavourite: boolean;
  /** The url for the character page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** Media that includes the character*/
  media?: Maybe<IMediaConnectionModel>;
  updatedAt?: Maybe<number>;
  /** The amount of user's who have favourited the character*/
  favourites?: Maybe<number>;
}

/** The names of the character */
export interface ICharacterNameModel {
  /** The character's given name*/
  first?: Maybe<string>;
  /** The character's surname*/
  last?: Maybe<string>;
  /** The character's full name*/
  full?: Maybe<string>;
  /** The character's full name in their native language*/
  native?: Maybe<string>;
  /** Other names the character might be referred to as*/
  alternative?: Maybe<string[]>;
}

export interface ICharacterImageModel {
  /** The character's image of media at its largest size*/
  large?: Maybe<string>;
  /** The character's image of media at medium size*/
  medium?: Maybe<string>;
}

/** Voice actors or production staff */
export interface IStaffModel {
  /** The id of the staff member*/
  id: number;
  /** The names of the staff member*/
  name?: Maybe<IStaffNameModel>;
  /** The primary language of the staff member*/
  language?: Maybe<IStaffLanguageModel>;
  /** The staff images*/
  image?: Maybe<IStaffImageModel>;
  /** A general description of the staff member*/
  description?: Maybe<string>;
  /** If the staff member is marked as favourite by the currently authenticated user*/
  isFavourite: boolean;
  /** The url for the staff page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** Media where the staff member has a production role*/
  staffMedia?: Maybe<IMediaConnectionModel>;
  /** Characters voiced by the actor*/
  characters?: Maybe<ICharacterConnectionModel>;
  updatedAt?: Maybe<number>;
  /** Staff member that the submission is referencing*/
  staff?: Maybe<IStaffModel>;
  /** Submitter for the submission*/
  submitter?: Maybe<IUserModel>;
  /** Status of the submission*/
  submissionStatus?: Maybe<number>;
  /** Inner details of submission status*/
  submissionNotes?: Maybe<string>;
  /** The amount of user's who have favourited the staff member*/
  favourites?: Maybe<number>;
}

/** The names of the staff member */
export interface IStaffNameModel {
  /** The person's given name*/
  first?: Maybe<string>;
  /** The person's surname*/
  last?: Maybe<string>;
  /** The person's full name*/
  full?: Maybe<string>;
  /** The person's full name in their native language*/
  native?: Maybe<string>;
  /** Other names the staff member might be referred to as (pen names)*/
  alternative?: Maybe<string[]>;
}

export interface IStaffImageModel {
  /** The person's image of media at its largest size*/
  large?: Maybe<string>;
  /** The person's image of media at medium size*/
  medium?: Maybe<string>;
}

export interface IStaffConnectionModel {
  edges?: Maybe<IStaffEdgeModel[]>;
  nodes?: Maybe<IStaffModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Staff connection edge */
export interface IStaffEdgeModel {
  node?: Maybe<IStaffModel>;
  /** The id of the connection*/
  id?: Maybe<number>;
  /** The role of the staff member in the production of the media*/
  role?: Maybe<string>;
  /** The order the staff should be displayed from the users favourites*/
  favouriteOrder?: Maybe<number>;
}

export interface IStudioConnectionModel {
  edges?: Maybe<IStudioEdgeModel[]>;
  nodes?: Maybe<IStudioModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Studio connection edge */
export interface IStudioEdgeModel {
  node?: Maybe<IStudioModel>;
  /** The id of the connection*/
  id?: Maybe<number>;
  /** If the studio is the main animation studio of the anime*/
  isMain: boolean;
  /** The order the character should be displayed from the users favourites*/
  favouriteOrder?: Maybe<number>;
}

/** Animation or production company */
export interface IStudioModel {
  /** The id of the studio*/
  id: number;
  /** The name of the studio*/
  name: string;
  /** If the studio is an animation studio or a different kind of company*/
  isAnimationStudio: boolean;
  /** The media the studio has worked on*/
  media?: Maybe<IMediaConnectionModel>;
  /** The url for the studio page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** If the studio is marked as favourite by the currently authenticated user*/
  isFavourite: boolean;
  /** The amount of user's who have favourited the studio*/
  favourites?: Maybe<number>;
}

/** Media Airing Schedule */
export interface IAiringScheduleModel {
  /** The id of the airing schedule item*/
  id: number;
  /** The time the episode airs at*/
  airingAt: number;
  /** Seconds until episode starts airing*/
  timeUntilAiring: number;
  /** The airing episode number*/
  episode: number;
  /** The associate media id of the airing episode*/
  mediaId: number;
  /** The associate media of the airing episode*/
  media?: Maybe<IMediaModel>;
}

export interface IAiringScheduleConnectionModel {
  edges?: Maybe<IAiringScheduleEdgeModel[]>;
  nodes?: Maybe<IAiringScheduleModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** AiringSchedule connection edge */
export interface IAiringScheduleEdgeModel {
  node?: Maybe<IAiringScheduleModel>;
  /** The id of the connection*/
  id?: Maybe<number>;
}

export interface IMediaTrendConnectionModel {
  edges?: Maybe<IMediaTrendEdgeModel[]>;
  nodes?: Maybe<IMediaTrendModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Media trend connection edge */
export interface IMediaTrendEdgeModel {
  node?: Maybe<IMediaTrendModel>;
}

/** Daily media statistics */
export interface IMediaTrendModel {
  /** The id of the tag*/
  mediaId: number;
  /** The day the data was recorded (timestamp)*/
  date: number;
  /** The amount of media activity on the day*/
  trending: number;
  /** A weighted average score of all the user's scores of the media*/
  averageScore?: Maybe<number>;
  /** The number of users with the media on their list*/
  popularity?: Maybe<number>;
  /** The number of users with watching/reading the media*/
  inProgress?: Maybe<number>;
  /** If the media was being released at this time*/
  releasing: boolean;
  /** The episode number of the anime released on this day*/
  episode?: Maybe<number>;
  /** The related media*/
  media?: Maybe<IMediaModel>;
}

/** An external link to another site related to the media */
export interface IMediaExternalLinkModel {
  /** The id of the external link*/
  id: number;
  /** The url of the external link*/
  url: string;
  /** The site location of the external link*/
  site: string;
}

/** Data and links to legal streaming episodes on external sites */
export interface IMediaStreamingEpisodeModel {
  /** Title of the episode*/
  title?: Maybe<string>;
  /** Url of episode image thumbnail*/
  thumbnail?: Maybe<string>;
  /** The url of the episode*/
  url?: Maybe<string>;
  /** The site location of the streaming episodes*/
  site?: Maybe<string>;
}

/** The ranking of a media in a particular time span and format compared to other media */
export interface IMediaRankModel {
  /** The id of the rank*/
  id: number;
  /** The numerical rank of the media*/
  rank: number;
  /** The type of ranking*/
  type: IMediaRankTypeModel;
  /** The format the media is ranked within*/
  format: IMediaFormatModel;
  /** The year the media is ranked within*/
  year?: Maybe<number>;
  /** The season the media is ranked within*/
  season?: Maybe<IMediaSeasonModel>;
  /** If the ranking is based on all time instead of a season/year*/
  allTime?: Maybe<boolean>;
  /** String that gives context to the ranking type and time span*/
  context: string;
}

/** List of anime or manga */
export interface IMediaListModel {
  /** The id of the list entry*/
  id: number;
  /** The id of the user owner of the list entry*/
  userId: number;
  /** The id of the media*/
  mediaId: number;
  /** The watching/reading status*/
  status?: Maybe<IMediaListStatusModel>;
  /** The score of the entry*/
  score?: Maybe<number>;
  /** The amount of episodes/chapters consumed by the user*/
  progress?: Maybe<number>;
  /** The amount of volumes read by the user*/
  progressVolumes?: Maybe<number>;
  /** The amount of times the user has rewatched/read the media*/
  repeat?: Maybe<number>;
  /** Priority of planning*/
  priority?: Maybe<number>;
  /** If the entry should only be visible to authenticated user*/
  private?: Maybe<boolean>;
  /** Text notes*/
  notes?: Maybe<string>;
  /** If the entry shown be hidden from non-custom lists*/
  hiddenFromStatusLists?: Maybe<boolean>;
  /** Map of booleans for which custom lists the entry are in*/
  customLists?: Maybe<string>;
  /** Map of advanced scores with name keys*/
  advancedScores?: Maybe<string>;
  /** When the entry was started by the user*/
  startedAt?: Maybe<IFuzzyDateModel>;
  /** When the entry was completed by the user*/
  completedAt?: Maybe<IFuzzyDateModel>;
  /** When the entry data was last updated*/
  updatedAt?: Maybe<number>;
  /** When the entry data was created*/
  createdAt?: Maybe<number>;
  media?: Maybe<IMediaModel>;
  user?: Maybe<IUserModel>;
}

export interface IReviewConnectionModel {
  edges?: Maybe<IReviewEdgeModel[]>;
  nodes?: Maybe<IReviewModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Review connection edge */
export interface IReviewEdgeModel {
  node?: Maybe<IReviewModel>;
}

/** A Review that features in an anime or manga */
export interface IReviewModel {
  /** The id of the review*/
  id: number;
  /** The id of the review's creator*/
  userId: number;
  /** The id of the review's media*/
  mediaId: number;
  /** For which type of media the review is for*/
  mediaType?: Maybe<IMediaTypeModel>;
  /** A short summary of the review*/
  summary?: Maybe<string>;
  /** The main review body text*/
  body?: Maybe<string>;
  /** The total user rating of the review*/
  rating?: Maybe<number>;
  /** The amount of user ratings of the review*/
  ratingAmount?: Maybe<number>;
  /** The rating of the review by currently authenticated user*/
  userRating?: Maybe<IReviewRatingModel>;
  /** The review score of the media*/
  score?: Maybe<number>;
  /** If the review is not yet publicly published and is only viewable by creator*/
  private?: Maybe<boolean>;
  /** The url for the review page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The time of the thread creation*/
  createdAt: number;
  /** The time of the thread last update*/
  updatedAt: number;
  /** The creator of the review*/
  user?: Maybe<IUserModel>;
  /** The media the review is of*/
  media?: Maybe<IMediaModel>;
}

export interface IRecommendationConnectionModel {
  edges?: Maybe<IRecommendationEdgeModel[]>;
  nodes?: Maybe<IRecommendationModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Recommendation connection edge */
export interface IRecommendationEdgeModel {
  node?: Maybe<IRecommendationModel>;
}

/** Media recommendation */
export interface IRecommendationModel {
  /** The id of the recommendation*/
  id: number;
  /** Users rating of the recommendation*/
  rating?: Maybe<number>;
  /** The rating of the recommendation by currently authenticated user*/
  userRating?: Maybe<IRecommendationRatingModel>;
  /** The media the recommendation is from*/
  media?: Maybe<IMediaModel>;
  /** The recommended media*/
  mediaRecommendation?: Maybe<IMediaModel>;
  /** The user that first created the recommendation*/
  user?: Maybe<IUserModel>;
}

/** A media's statistics */
export interface IMediaStatsModel {
  scoreDistribution?: Maybe<IScoreDistributionModel[]>;
  statusDistribution?: Maybe<IStatusDistributionModel[]>;
  airingProgression?: Maybe<IAiringProgressionModel[]>;
}

/** A user's list score distribution. */
export interface IScoreDistributionModel {
  score?: Maybe<number>;
  /** The amount of list entries with this score*/
  amount?: Maybe<number>;
}

/** The distribution of the watching/reading status of media or a user's list */
export interface IStatusDistributionModel {
  /** The day the activity took place (Unix timestamp)*/
  status?: Maybe<IMediaListStatusModel>;
  /** The amount of entries with this status*/
  amount?: Maybe<number>;
}

/** Score & Watcher stats for airing anime by episode and mid-week */
export interface IAiringProgressionModel {
  /** The episode the stats were recorded at. .5 is the mid point between 2 episodes airing dates.*/
  episode?: Maybe<number>;
  /** The average score for the media*/
  score?: Maybe<number>;
  /** The amount of users watching the anime*/
  watching?: Maybe<number>;
}

export interface IUserStatisticTypesModel {
  anime?: Maybe<IUserStatisticsModel>;
  manga?: Maybe<IUserStatisticsModel>;
}

export interface IUserStatisticsModel {
  count: number;
  meanScore: number;
  standardDeviation: number;
  minutesWatched: number;
  episodesWatched: number;
  chaptersRead: number;
  volumesRead: number;
  formats?: Maybe<IUserFormatStatisticModel[]>;
  statuses?: Maybe<IUserStatusStatisticModel[]>;
  scores?: Maybe<IUserScoreStatisticModel[]>;
  lengths?: Maybe<IUserLengthStatisticModel[]>;
  releaseYears?: Maybe<IUserReleaseYearStatisticModel[]>;
  startYears?: Maybe<IUserStartYearStatisticModel[]>;
  genres?: Maybe<IUserGenreStatisticModel[]>;
  tags?: Maybe<IUserTagStatisticModel[]>;
  countries?: Maybe<IUserCountryStatisticModel[]>;
  voiceActors?: Maybe<IUserVoiceActorStatisticModel[]>;
  staff?: Maybe<IUserStaffStatisticModel[]>;
  studios?: Maybe<IUserStudioStatisticModel[]>;
}

export interface IUserFormatStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  format?: Maybe<IMediaFormatModel>;
}

export interface IUserStatusStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  status?: Maybe<IMediaListStatusModel>;
}

export interface IUserScoreStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  score?: Maybe<number>;
}

export interface IUserLengthStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  length?: Maybe<string>;
}

export interface IUserReleaseYearStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  releaseYear?: Maybe<number>;
}

export interface IUserStartYearStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  startYear?: Maybe<number>;
}

export interface IUserGenreStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  genre?: Maybe<string>;
}

export interface IUserTagStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  tag?: Maybe<IMediaTagModel>;
}

export interface IUserCountryStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  country?: Maybe<undefined>;
}

export interface IUserVoiceActorStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  voiceActor?: Maybe<IStaffModel>;
  characterIds: number[];
}

export interface IUserStaffStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  staff?: Maybe<IStaffModel>;
}

export interface IUserStudioStatisticModel {
  count: number;
  meanScore: number;
  minutesWatched: number;
  chaptersRead: number;
  mediaIds: number[];
  studio?: Maybe<IStudioModel>;
}

/** A user's statistics */
export interface IUserStatsModel {
  /** The amount of anime the user has watched in minutes*/
  watchedTime?: Maybe<number>;
  /** The amount of manga chapters the user has read*/
  chaptersRead?: Maybe<number>;
  activityHistory?: Maybe<IUserActivityHistoryModel[]>;
  animeStatusDistribution?: Maybe<IStatusDistributionModel[]>;
  mangaStatusDistribution?: Maybe<IStatusDistributionModel[]>;
  animeScoreDistribution?: Maybe<IScoreDistributionModel[]>;
  mangaScoreDistribution?: Maybe<IScoreDistributionModel[]>;
  animeListScores?: Maybe<IListScoreStatsModel>;
  mangaListScores?: Maybe<IListScoreStatsModel>;
  favouredGenresOverview?: Maybe<IGenreStatsModel[]>;
  favouredGenres?: Maybe<IGenreStatsModel[]>;
  favouredTags?: Maybe<ITagStatsModel[]>;
  favouredActors?: Maybe<IStaffStatsModel[]>;
  favouredStaff?: Maybe<IStaffStatsModel[]>;
  favouredStudios?: Maybe<IStudioStatsModel[]>;
  favouredYears?: Maybe<IYearStatsModel[]>;
  favouredFormats?: Maybe<IFormatStatsModel[]>;
}

/** A user's activity history stats. */
export interface IUserActivityHistoryModel {
  /** The day the activity took place (Unix timestamp)*/
  date?: Maybe<number>;
  /** The amount of activity on the day*/
  amount?: Maybe<number>;
  /** The level of activity represented on a 1-10 scale*/
  level?: Maybe<number>;
}

/** User's list score statistics */
export interface IListScoreStatsModel {
  meanScore?: Maybe<number>;
  standardDeviation?: Maybe<number>;
}

/** User's genre statistics */
export interface IGenreStatsModel {
  genre?: Maybe<string>;
  amount?: Maybe<number>;
  meanScore?: Maybe<number>;
  /** The amount of time in minutes the genre has been watched by the user*/
  timeWatched?: Maybe<number>;
}

/** User's tag statistics */
export interface ITagStatsModel {
  tag?: Maybe<IMediaTagModel>;
  amount?: Maybe<number>;
  meanScore?: Maybe<number>;
  /** The amount of time in minutes the tag has been watched by the user*/
  timeWatched?: Maybe<number>;
}

/** User's staff statistics */
export interface IStaffStatsModel {
  staff?: Maybe<IStaffModel>;
  amount?: Maybe<number>;
  meanScore?: Maybe<number>;
  /** The amount of time in minutes the staff member has been watched by the user*/
  timeWatched?: Maybe<number>;
}

/** User's studio statistics */
export interface IStudioStatsModel {
  studio?: Maybe<IStudioModel>;
  amount?: Maybe<number>;
  meanScore?: Maybe<number>;
  /** The amount of time in minutes the studio's works have been watched by the user*/
  timeWatched?: Maybe<number>;
}

/** User's year statistics */
export interface IYearStatsModel {
  year?: Maybe<number>;
  amount?: Maybe<number>;
  meanScore?: Maybe<number>;
}

/** User's format statistics */
export interface IFormatStatsModel {
  format?: Maybe<IMediaFormatModel>;
  amount?: Maybe<number>;
}

/** Notification for when an episode of anime airs */
export interface IAiringNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the aired anime*/
  animeId: number;
  /** The episode number that just aired*/
  episode: number;
  /** The notification context text*/
  contexts?: Maybe<string[]>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The associated media of the airing schedule*/
  media?: Maybe<IMediaModel>;
}

/** Notification for when the authenticated user is followed by another user */
export interface IFollowingNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who followed the authenticated user*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a user is send an activity message */
export interface IActivityMessageNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The if of the user who send the message*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity message*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The message activity*/
  message?: Maybe<IMessageActivityModel>;
  /** The user who sent the message*/
  user?: Maybe<IUserModel>;
}

/** User message activity */
export interface IMessageActivityModel {
  /** The id of the activity*/
  id: number;
  /** The user id of the activity's recipient*/
  recipientId?: Maybe<number>;
  /** The user id of the activity's sender*/
  messengerId?: Maybe<number>;
  /** The type of the activity*/
  type?: Maybe<IActivityTypeModel>;
  /** The number of activity replies*/
  replyCount: number;
  /** The message text (Markdown)*/
  message?: Maybe<string>;
  /** If the activity is locked and can receive replies*/
  isLocked?: Maybe<boolean>;
  /** If the currently authenticated user is subscribed to the activity*/
  isSubscribed?: Maybe<boolean>;
  /** The amount of likes the activity has*/
  likeCount: number;
  /** If the currently authenticated user liked the activity*/
  isLiked?: Maybe<boolean>;
  /** If the message is private and only viewable to the sender and recipients*/
  isPrivate?: Maybe<boolean>;
  /** The url for the activity page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The time the activity was created at*/
  createdAt: number;
  /** The user who the activity message was sent to*/
  recipient?: Maybe<IUserModel>;
  /** The user who sent the activity message*/
  messenger?: Maybe<IUserModel>;
  /** The written replies to the activity*/
  replies?: Maybe<IActivityReplyModel[]>;
  /** The users who liked the activity*/
  likes?: Maybe<IUserModel[]>;
}

/** Replay to an activity item */
export interface IActivityReplyModel {
  /** The id of the reply*/
  id: number;
  /** The id of the replies creator*/
  userId?: Maybe<number>;
  /** The id of the parent activity*/
  activityId?: Maybe<number>;
  /** The reply text*/
  text?: Maybe<string>;
  /** The amount of likes the reply has*/
  likeCount: number;
  /** If the currently authenticated user liked the reply*/
  isLiked?: Maybe<boolean>;
  /** The time the reply was created at*/
  createdAt: number;
  /** The user who created reply*/
  user?: Maybe<IUserModel>;
  /** The users who liked the reply*/
  likes?: Maybe<IUserModel[]>;
}

/** Notification for when authenticated user is @ mentioned in activity or reply */
export interface IActivityMentionNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who mentioned the authenticated user*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity where mentioned*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  activity?: Maybe<IActivityUnionModel>;
  /** The user who mentioned the authenticated user*/
  user?: Maybe<IUserModel>;
}

/** User text activity */
export interface ITextActivityModel {
  /** The id of the activity*/
  id: number;
  /** The user id of the activity's creator*/
  userId?: Maybe<number>;
  /** The type of activity*/
  type?: Maybe<IActivityTypeModel>;
  /** The number of activity replies*/
  replyCount: number;
  /** The status text (Markdown)*/
  text?: Maybe<string>;
  /** The url for the activity page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** If the activity is locked and can receive replies*/
  isLocked?: Maybe<boolean>;
  /** If the currently authenticated user is subscribed to the activity*/
  isSubscribed?: Maybe<boolean>;
  /** The amount of likes the activity has*/
  likeCount: number;
  /** If the currently authenticated user liked the activity*/
  isLiked?: Maybe<boolean>;
  /** The time the activity was created at*/
  createdAt: number;
  /** The user who created the activity*/
  user?: Maybe<IUserModel>;
  /** The written replies to the activity*/
  replies?: Maybe<IActivityReplyModel[]>;
  /** The users who liked the activity*/
  likes?: Maybe<IUserModel[]>;
}

/** User list activity (anime & manga updates) */
export interface IListActivityModel {
  /** The id of the activity*/
  id: number;
  /** The user id of the activity's creator*/
  userId?: Maybe<number>;
  /** The type of activity*/
  type?: Maybe<IActivityTypeModel>;
  /** The number of activity replies*/
  replyCount: number;
  /** The list item's textual status*/
  status?: Maybe<string>;
  /** The list progress made*/
  progress?: Maybe<string>;
  /** If the activity is locked and can receive replies*/
  isLocked?: Maybe<boolean>;
  /** If the currently authenticated user is subscribed to the activity*/
  isSubscribed?: Maybe<boolean>;
  /** The amount of likes the activity has*/
  likeCount: number;
  /** If the currently authenticated user liked the activity*/
  isLiked?: Maybe<boolean>;
  /** The url for the activity page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The time the activity was created at*/
  createdAt: number;
  /** The owner of the activity*/
  user?: Maybe<IUserModel>;
  /** The associated media to the activity update*/
  media?: Maybe<IMediaModel>;
  /** The written replies to the activity*/
  replies?: Maybe<IActivityReplyModel[]>;
  /** The users who liked the activity*/
  likes?: Maybe<IUserModel[]>;
}

/** Notification for when a user replies to the authenticated users activity */
export interface IActivityReplyNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who replied to the activity*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity which was replied too*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  activity?: Maybe<IActivityUnionModel>;
  /** The user who replied to the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a user replies to activity the authenticated user has replied to */
export interface IActivityReplySubscribedNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who replied to the activity*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity which was replied too*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  activity?: Maybe<IActivityUnionModel>;
  /** The user who replied to the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a activity is liked */
export interface IActivityLikeNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who liked to the activity*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity which was liked*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  activity?: Maybe<IActivityUnionModel>;
  /** The user who liked the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a activity reply is liked */
export interface IActivityReplyLikeNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who liked to the activity reply*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity where the reply which was liked*/
  activityId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The liked activity*/
  activity?: Maybe<IActivityUnionModel>;
  /** The user who liked the activity reply*/
  user?: Maybe<IUserModel>;
}

/** Notification for when authenticated user is @ mentioned in a forum thread comment */
export interface IThreadCommentMentionNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who mentioned the authenticated user*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the comment where mentioned*/
  commentId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The thread that the relevant comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The thread comment that included the @ mention*/
  comment?: Maybe<IThreadCommentModel>;
  /** The user who mentioned the authenticated user*/
  user?: Maybe<IUserModel>;
}

/** Forum Thread */
export interface IThreadModel {
  /** The id of the thread*/
  id: number;
  /** The title of the thread*/
  title?: Maybe<string>;
  /** The text body of the thread (Markdown)*/
  body?: Maybe<string>;
  /** The id of the thread owner user*/
  userId: number;
  /** The id of the user who most recently commented on the thread*/
  replyUserId?: Maybe<number>;
  /** The id of the most recent comment on the thread*/
  replyCommentId?: Maybe<number>;
  /** The number of comments on the thread*/
  replyCount?: Maybe<number>;
  /** The number of times users have viewed the thread*/
  viewCount?: Maybe<number>;
  /** If the thread is locked and can receive comments*/
  isLocked?: Maybe<boolean>;
  /** If the thread is stickied and should be displayed at the top of the page*/
  isSticky?: Maybe<boolean>;
  /** If the currently authenticated user is subscribed to the thread*/
  isSubscribed?: Maybe<boolean>;
  /** The amount of likes the thread has*/
  likeCount: number;
  /** If the currently authenticated user liked the thread*/
  isLiked?: Maybe<boolean>;
  /** The time of the last reply*/
  repliedAt?: Maybe<number>;
  /** The time of the thread creation*/
  createdAt: number;
  /** The time of the thread last update*/
  updatedAt: number;
  /** The owner of the thread*/
  user?: Maybe<IUserModel>;
  /** The user to last reply to the thread*/
  replyUser?: Maybe<IUserModel>;
  /** The users who liked the thread*/
  likes?: Maybe<IUserModel[]>;
  /** The url for the thread page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The categories of the thread*/
  categories?: Maybe<IThreadCategoryModel[]>;
  /** The media categories of the thread*/
  mediaCategories?: Maybe<IMediaModel[]>;
}

/** A forum thread category */
export interface IThreadCategoryModel {
  /** The id of the category*/
  id: number;
  /** The name of the category*/
  name: string;
}

/** Forum Thread Comment */
export interface IThreadCommentModel {
  /** The id of the comment*/
  id: number;
  /** The user id of the comment's owner*/
  userId?: Maybe<number>;
  /** The id of thread the comment belongs to*/
  threadId?: Maybe<number>;
  /** The text content of the comment (Markdown)*/
  comment?: Maybe<string>;
  /** The amount of likes the comment has*/
  likeCount: number;
  /** If the currently authenticated user liked the comment*/
  isLiked?: Maybe<boolean>;
  /** The url for the comment page on the AniList website*/
  siteUrl?: Maybe<string>;
  /** The time of the comments creation*/
  createdAt: number;
  /** The time of the comments last update*/
  updatedAt: number;
  /** The thread the comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The user who created the comment*/
  user?: Maybe<IUserModel>;
  /** The users who liked the comment*/
  likes?: Maybe<IUserModel[]>;
  /** The comment's child reply comments*/
  childComments?: Maybe<string>;
}

/** Notification for when a user replies to your forum thread comment */
export interface IThreadCommentReplyNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who create the comment reply*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the reply comment*/
  commentId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The thread that the relevant comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The reply thread comment*/
  comment?: Maybe<IThreadCommentModel>;
  /** The user who replied to the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a user replies to a subscribed forum thread */
export interface IThreadCommentSubscribedNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who commented on the thread*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the new comment in the subscribed thread*/
  commentId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The thread that the relevant comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The reply thread comment*/
  comment?: Maybe<IThreadCommentModel>;
  /** The user who replied to the subscribed thread*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a thread comment is liked */
export interface IThreadCommentLikeNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who liked to the activity*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the activity which was liked*/
  commentId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The thread that the relevant comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The thread comment that was liked*/
  comment?: Maybe<IThreadCommentModel>;
  /** The user who liked the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when a thread is liked */
export interface IThreadLikeNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The id of the user who liked to the activity*/
  userId: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the thread which was liked*/
  threadId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The thread that the relevant comment belongs to*/
  thread?: Maybe<IThreadModel>;
  /** The liked thread comment*/
  comment?: Maybe<IThreadCommentModel>;
  /** The user who liked the activity*/
  user?: Maybe<IUserModel>;
}

/** Notification for when new media is added to the site */
export interface IRelatedMediaAdditionNotificationModel {
  /** The id of the Notification*/
  id: number;
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** The id of the new media*/
  mediaId: number;
  /** The notification context text*/
  context?: Maybe<string>;
  /** The time the notification was created at*/
  createdAt?: Maybe<number>;
  /** The associated media of the airing schedule*/
  media?: Maybe<IMediaModel>;
}

/** List of anime or manga */
export interface IMediaListCollectionModel {
  /** Grouped media list entries*/
  lists?: Maybe<IMediaListGroupModel[]>;
  /** The owner of the list*/
  user?: Maybe<IUserModel>;
  /** If there is another chunk*/
  hasNextChunk?: Maybe<boolean>;
  /** A map of media list entry arrays grouped by status*/
  statusLists?: Maybe<IMediaListModel[]>;
  /** A map of media list entry arrays grouped by custom lists*/
  customLists?: Maybe<IMediaListModel[]>;
}

/** List group of anime or manga entries */
export interface IMediaListGroupModel {
  /** Media list entries*/
  entries?: Maybe<IMediaListModel[]>;
  name?: Maybe<string>;
  isCustomList?: Maybe<boolean>;
  isSplitCompletedList?: Maybe<boolean>;
  status?: Maybe<IMediaListStatusModel>;
}

/** Provides the parsed markdown as html */
export interface IParsedMarkdownModel {
  /** The parsed markdown as html*/
  html?: Maybe<string>;
}

export interface IAniChartUserModel {
  user?: Maybe<IUserModel>;
  settings?: Maybe<string>;
  highlights?: Maybe<string>;
}

export interface ISiteStatisticsModel {
  users?: Maybe<ISiteTrendConnectionModel>;
  anime?: Maybe<ISiteTrendConnectionModel>;
  manga?: Maybe<ISiteTrendConnectionModel>;
  characters?: Maybe<ISiteTrendConnectionModel>;
  staff?: Maybe<ISiteTrendConnectionModel>;
  studios?: Maybe<ISiteTrendConnectionModel>;
  reviews?: Maybe<ISiteTrendConnectionModel>;
}

export interface ISiteTrendConnectionModel {
  edges?: Maybe<ISiteTrendEdgeModel[]>;
  nodes?: Maybe<ISiteTrendModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** Site trend connection edge */
export interface ISiteTrendEdgeModel {
  node?: Maybe<ISiteTrendModel>;
}

/** Daily site statistics */
export interface ISiteTrendModel {
  /** The day the data was recorded (timestamp)*/
  date: number;
  count: number;
  /** The change from yesterday*/
  change: number;
}

export interface IMutationModel {
  UpdateUser?: Maybe<IUserModel>;
  /** Create or update a media list entry*/
  SaveMediaListEntry?: Maybe<IMediaListModel>;
  /** Update multiple media list entries to the same values*/
  UpdateMediaListEntries?: Maybe<IMediaListModel[]>;
  /** Delete a media list entry*/
  DeleteMediaListEntry?: Maybe<IDeletedModel>;
  /** Delete a custom list and remove the list entries from it*/
  DeleteCustomList?: Maybe<IDeletedModel>;
  /** Create or update text activity for the currently authenticated user*/
  SaveTextActivity?: Maybe<ITextActivityModel>;
  /** Create or update message activity for the currently authenticated user*/
  SaveMessageActivity?: Maybe<IMessageActivityModel>;
  /** Update list activity (Mod Only)*/
  SaveListActivity?: Maybe<IListActivityModel>;
  /** Delete an activity item of the authenticated users*/
  DeleteActivity?: Maybe<IDeletedModel>;
  /** Toggle the subscription of an activity item*/
  ToggleActivitySubscription?: Maybe<IActivityUnionModel>;
  /** Create or update an activity reply*/
  SaveActivityReply?: Maybe<IActivityReplyModel>;
  /** Delete an activity reply of the authenticated users*/
  DeleteActivityReply?: Maybe<IDeletedModel>;
  /** Add or remove a like from a likeable type.
                          Returns all the users who liked the same model*/
  ToggleLike?: Maybe<IUserModel[]>;
  /** Add or remove a like from a likeable type.*/
  ToggleLikeV2?: Maybe<ILikeableUnionModel>;
  /** Toggle the un/following of a user*/
  ToggleFollow?: Maybe<IUserModel>;
  /** Favourite or unfavourite an anime, manga, character, staff member, or studio*/
  ToggleFavourite?: Maybe<IFavouritesModel>;
  /** Update the order favourites are displayed in*/
  UpdateFavouriteOrder?: Maybe<IFavouritesModel>;
  /** Create or update a review*/
  SaveReview?: Maybe<IReviewModel>;
  /** Delete a review*/
  DeleteReview?: Maybe<IDeletedModel>;
  /** Rate a review*/
  RateReview?: Maybe<IReviewModel>;
  /** Recommendation a media*/
  SaveRecommendation?: Maybe<IRecommendationModel>;
  /** Create or update a forum thread*/
  SaveThread?: Maybe<IThreadModel>;
  /** Delete a thread*/
  DeleteThread?: Maybe<IDeletedModel>;
  /** Toggle the subscription of a forum thread*/
  ToggleThreadSubscription?: Maybe<IThreadModel>;
  /** Create or update a thread comment*/
  SaveThreadComment?: Maybe<IThreadCommentModel>;
  /** Delete a thread comment*/
  DeleteThreadComment?: Maybe<IDeletedModel>;
  UpdateAniChartSettings?: Maybe<string>;
  UpdateAniChartHighlights?: Maybe<string>;
}

/** Notification option input */
export interface INotificationOptionInputModel {
  /** The type of notification*/
  type?: Maybe<INotificationTypeModel>;
  /** Whether this type of notification is enabled*/
  enabled?: Maybe<boolean>;
}

/** A user's list options for anime or manga lists */
export interface IMediaListOptionsInputModel {
  /** The order each list should be displayed in*/
  sectionOrder?: Maybe<string[]>;
  /** If the completed sections of the list should be separated by format*/
  splitCompletedSectionByFormat?: Maybe<boolean>;
  /** The names of the user's custom lists*/
  customLists?: Maybe<string[]>;
  /** The names of the user's advanced scoring sections*/
  advancedScoring?: Maybe<string[]>;
  /** If advanced scoring is enabled*/
  advancedScoringEnabled?: Maybe<boolean>;
  /** list theme*/
  theme?: Maybe<string>;
}

/** Date object that allows for incomplete date values (fuzzy) */
export interface IFuzzyDateInputModel {
  /** Numeric Year (2017)*/
  year?: Maybe<number>;
  /** Numeric Month (3)*/
  month?: Maybe<number>;
  /** Numeric Day (24)*/
  day?: Maybe<number>;
}

/** Deleted data type */
export interface IDeletedModel {
  /** If an item has been successfully deleted*/
  deleted?: Maybe<boolean>;
}

export interface IAniChartHighlightInputModel {
  mediaId?: Maybe<number>;
  highlight?: Maybe<string>;
}

/** Page of data (Used for internal use only) */
export interface IInternalPageModel {
  mediaSubmissions?: Maybe<IMediaSubmissionModel[]>;
  characterSubmissions?: Maybe<ICharacterSubmissionModel[]>;
  staffSubmissions?: Maybe<IStaffSubmissionModel[]>;
  revisionHistory?: Maybe<IRevisionHistoryModel[]>;
  reports?: Maybe<IReportModel[]>;
  modActions?: Maybe<IModActionModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
  users?: Maybe<IUserModel[]>;
  media?: Maybe<IMediaModel[]>;
  characters?: Maybe<ICharacterModel[]>;
  staff?: Maybe<IStaffModel[]>;
  studios?: Maybe<IStudioModel[]>;
  mediaList?: Maybe<IMediaListModel[]>;
  airingSchedules?: Maybe<IAiringScheduleModel[]>;
  mediaTrends?: Maybe<IMediaTrendModel[]>;
  notifications?: Maybe<INotificationUnionModel[]>;
  followers?: Maybe<IUserModel[]>;
  following?: Maybe<IUserModel[]>;
  activities?: Maybe<IActivityUnionModel[]>;
  activityReplies?: Maybe<IActivityReplyModel[]>;
  threads?: Maybe<IThreadModel[]>;
  threadComments?: Maybe<IThreadCommentModel[]>;
  reviews?: Maybe<IReviewModel[]>;
  recommendations?: Maybe<IRecommendationModel[]>;
  likes?: Maybe<IUserModel[]>;
}

/** Media submission */
export interface IMediaSubmissionModel {
  /** The id of the submission*/
  id: number;
  /** User submitter of the submission*/
  submitter?: Maybe<IUserModel>;
  /** Status of the submission*/
  status?: Maybe<ISubmissionStatusModel>;
  submitterStats?: Maybe<string>;
  notes?: Maybe<string>;
  source?: Maybe<string>;
  changes?: Maybe<string[]>;
  media?: Maybe<IMediaModel>;
  submission?: Maybe<IMediaModel>;
  characters?: Maybe<IMediaSubmissionComparisonModel[]>;
  staff?: Maybe<IMediaSubmissionComparisonModel[]>;
  studios?: Maybe<IMediaSubmissionComparisonModel[]>;
  relations?: Maybe<IMediaEdgeModel[]>;
  externalLinks?: Maybe<IMediaExternalLinkModel[]>;
  createdAt?: Maybe<number>;
}

/** Media submission with comparison to current data */
export interface IMediaSubmissionComparisonModel {
  submission?: Maybe<IMediaSubmissionEdgeModel>;
  character?: Maybe<IMediaCharacterModel>;
  staff?: Maybe<IStaffEdgeModel>;
  studio?: Maybe<IStudioEdgeModel>;
}

export interface IMediaSubmissionEdgeModel {
  /** The id of the direct submission*/
  id?: Maybe<number>;
  characterRole?: Maybe<ICharacterRoleModel>;
  staffRole?: Maybe<string>;
  isMain?: Maybe<boolean>;
  character?: Maybe<ICharacterModel>;
  characterSubmission?: Maybe<ICharacterModel>;
  voiceActor?: Maybe<IStaffModel>;
  voiceActorSubmission?: Maybe<IStaffModel>;
  staff?: Maybe<IStaffModel>;
  staffSubmission?: Maybe<IStaffModel>;
  studio?: Maybe<IStudioModel>;
  media?: Maybe<IMediaModel>;
}

/** Internal - Media characters separated */
export interface IMediaCharacterModel {
  /** The id of the connection*/
  id?: Maybe<number>;
  /** The characters role in the media*/
  role?: Maybe<ICharacterRoleModel>;
  /** The characters in the media voiced by the parent actor*/
  character?: Maybe<ICharacterModel>;
  /** The voice actor of the character*/
  voiceActor?: Maybe<IStaffModel>;
}

/** A submission for a character that features in an anime or manga */
export interface ICharacterSubmissionModel {
  /** The id of the submission*/
  id: number;
  /** Character that the submission is referencing*/
  character?: Maybe<ICharacterModel>;
  /** The character submission changes*/
  submission?: Maybe<ICharacterModel>;
  /** Submitter for the submission*/
  submitter?: Maybe<IUserModel>;
  /** Status of the submission*/
  status?: Maybe<ISubmissionStatusModel>;
  /** Inner details of submission status*/
  notes?: Maybe<string>;
  createdAt?: Maybe<number>;
}

/** A submission for a staff that features in an anime or manga */
export interface IStaffSubmissionModel {
  /** The id of the submission*/
  id: number;
  /** Staff that the submission is referencing*/
  staff?: Maybe<IStaffModel>;
  /** The staff submission changes*/
  submission?: Maybe<IStaffModel>;
  /** Submitter for the submission*/
  submitter?: Maybe<IUserModel>;
  /** Status of the submission*/
  status?: Maybe<ISubmissionStatusModel>;
  /** Inner details of submission status*/
  notes?: Maybe<string>;
  createdAt?: Maybe<number>;
}

/** Feed of mod edit activity */
export interface IRevisionHistoryModel {
  /** The id of the media*/
  id: number;
  /** The action taken on the objects*/
  action?: Maybe<IRevisionHistoryActionModel>;
  /** A JSON object of the fields that changed*/
  changes?: Maybe<string>;
  /** The user who made the edit to the object*/
  user?: Maybe<IUserModel>;
  /** The media the mod feed entry references*/
  media?: Maybe<IMediaModel>;
  /** The character the mod feed entry references*/
  character?: Maybe<ICharacterModel>;
  /** The staff member the mod feed entry references*/
  staff?: Maybe<IStaffModel>;
  /** The studio the mod feed entry references*/
  studio?: Maybe<IStudioModel>;
  /** When the mod feed entry was created*/
  createdAt?: Maybe<number>;
}

export interface IReportModel {
  id: number;
  reporter?: Maybe<IUserModel>;
  reported?: Maybe<IUserModel>;
  reason?: Maybe<string>;
  /** When the entry data was created*/
  createdAt?: Maybe<number>;
}

export interface IModActionModel {
  /** The id of the action*/
  id: number;
  user?: Maybe<IUserModel>;
  mod?: Maybe<IUserModel>;
  type?: Maybe<IModActionTypeModel>;
  objectId?: Maybe<number>;
  objectType?: Maybe<string>;
  data?: Maybe<string>;
  createdAt: number;
}

/** The official titles of the media in various languages */
export interface IMediaTitleInputModel {
  /** The romanization of the native language title*/
  romaji?: Maybe<string>;
  /** The official english title*/
  english?: Maybe<string>;
  /** Official title in it's native language*/
  native?: Maybe<string>;
}

/** An external link to another site related to the media */
export interface IMediaExternalLinkInputModel {
  /** The id of the external link*/
  id: number;
  /** The url of the external link*/
  url: string;
  /** The site location of the external link*/
  site: string;
}

export interface IAiringScheduleInputModel {
  airingAt?: Maybe<number>;
  episode?: Maybe<number>;
  timeUntilAiring?: Maybe<number>;
}

/** The names of the character */
export interface ICharacterNameInputModel {
  /** The character's given name*/
  first?: Maybe<string>;
  /** The character's surname*/
  last?: Maybe<string>;
  /** The character's full name in their native language*/
  native?: Maybe<string>;
  /** Other names the character might be referred by*/
  alternative?: Maybe<string[]>;
}

export interface ICharacterSubmissionConnectionModel {
  edges?: Maybe<ICharacterSubmissionEdgeModel[]>;
  nodes?: Maybe<ICharacterSubmissionModel[]>;
  /** The pagination information*/
  pageInfo?: Maybe<IPageInfoModel>;
}

/** CharacterSubmission connection edge */
export interface ICharacterSubmissionEdgeModel {
  node?: Maybe<ICharacterSubmissionModel>;
  /** The characters role in the media*/
  role?: Maybe<ICharacterRoleModel>;
  /** The voice actors of the character*/
  voiceActors?: Maybe<IStaffModel[]>;
  /** The submitted voice actors of the character*/
  submittedVoiceActors?: Maybe<IStaffSubmissionModel[]>;
}

/** The names of the staff member */
export interface IStaffNameInputModel {
  /** The person's given name*/
  first?: Maybe<string>;
  /** The person's surname*/
  last?: Maybe<string>;
  /** The person's full name in their native language*/
  native?: Maybe<string>;
  /** Other names the character might be referred by*/
  alternative?: Maybe<string[]>;
}

/** User data for moderators */
export interface IUserModDataModel {
  alts?: Maybe<IUserModel[]>;
  bans?: Maybe<string>;
  ip?: Maybe<string>;
  counts?: Maybe<string>;
}

/** User sort enums */
export enum IUserSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Username = 'USERNAME',
  Username_desc = 'USERNAME_DESC',
  Watched_time = 'WATCHED_TIME',
  Watched_time_desc = 'WATCHED_TIME_DESC',
  Chapters_read = 'CHAPTERS_READ',
  Chapters_read_desc = 'CHAPTERS_READ_DESC',
  Search_match = 'SEARCH_MATCH'
}
/** The language the user wants to see media titles in */
export enum IUserTitleLanguageModel {
  Romaji = 'ROMAJI',
  English = 'ENGLISH',
  Native = 'NATIVE',
  Romaji_stylised = 'ROMAJI_STYLISED',
  English_stylised = 'ENGLISH_STYLISED',
  Native_stylised = 'NATIVE_STYLISED'
}
/** Notification type enum */
export enum INotificationTypeModel {
  Activity_message = 'ACTIVITY_MESSAGE',
  Activity_reply = 'ACTIVITY_REPLY',
  Following = 'FOLLOWING',
  Activity_mention = 'ACTIVITY_MENTION',
  Thread_comment_mention = 'THREAD_COMMENT_MENTION',
  Thread_subscribed = 'THREAD_SUBSCRIBED',
  Thread_comment_reply = 'THREAD_COMMENT_REPLY',
  Airing = 'AIRING',
  Activity_like = 'ACTIVITY_LIKE',
  Activity_reply_like = 'ACTIVITY_REPLY_LIKE',
  Thread_like = 'THREAD_LIKE',
  Thread_comment_like = 'THREAD_COMMENT_LIKE',
  Activity_reply_subscribed = 'ACTIVITY_REPLY_SUBSCRIBED',
  Related_media_addition = 'RELATED_MEDIA_ADDITION'
}
/** Media list scoring type */
export enum IScoreFormatModel {
  Point_100 = 'POINT_100',
  Point_10_decimal = 'POINT_10_DECIMAL',
  Point_10 = 'POINT_10',
  Point_5 = 'POINT_5',
  Point_3 = 'POINT_3'
}
/** Media type enum, anime or manga. */
export enum IMediaTypeModel {
  Anime = 'ANIME',
  Manga = 'MANGA'
}
/** The format the media was released in */
export enum IMediaFormatModel {
  Tv = 'TV',
  Tv_short = 'TV_SHORT',
  Movie = 'MOVIE',
  Special = 'SPECIAL',
  Ova = 'OVA',
  Ona = 'ONA',
  Music = 'MUSIC',
  Manga = 'MANGA',
  Novel = 'NOVEL',
  One_shot = 'ONE_SHOT'
}
/** The current releasing status of the media */
export enum IMediaStatusModel {
  Finished = 'FINISHED',
  Releasing = 'RELEASING',
  Not_yet_released = 'NOT_YET_RELEASED',
  Cancelled = 'CANCELLED'
}
export enum IMediaSeasonModel {
  Winter = 'WINTER',
  Spring = 'SPRING',
  Summer = 'SUMMER',
  Fall = 'FALL'
}
/** Source type the media was adapted from */
export enum IMediaSourceModel {
  Original = 'ORIGINAL',
  Manga = 'MANGA',
  Light_novel = 'LIGHT_NOVEL',
  Visual_novel = 'VISUAL_NOVEL',
  Video_game = 'VIDEO_GAME',
  Other = 'OTHER',
  Novel = 'NOVEL',
  Doujinshi = 'DOUJINSHI',
  Anime = 'ANIME'
}
/** Character sort enums */
export enum ICharacterSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Role = 'ROLE',
  Role_desc = 'ROLE_DESC',
  Search_match = 'SEARCH_MATCH',
  Favourites = 'FAVOURITES',
  Favourites_desc = 'FAVOURITES_DESC'
}
/** The role the character plays in the media */
export enum ICharacterRoleModel {
  Main = 'MAIN',
  Supporting = 'SUPPORTING',
  Background = 'BACKGROUND'
}
/** Media sort enums */
export enum IMediaSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Title_romaji = 'TITLE_ROMAJI',
  Title_romaji_desc = 'TITLE_ROMAJI_DESC',
  Title_english = 'TITLE_ENGLISH',
  Title_english_desc = 'TITLE_ENGLISH_DESC',
  Title_native = 'TITLE_NATIVE',
  Title_native_desc = 'TITLE_NATIVE_DESC',
  Type = 'TYPE',
  Type_desc = 'TYPE_DESC',
  Format = 'FORMAT',
  Format_desc = 'FORMAT_DESC',
  Start_date = 'START_DATE',
  Start_date_desc = 'START_DATE_DESC',
  End_date = 'END_DATE',
  End_date_desc = 'END_DATE_DESC',
  Score = 'SCORE',
  Score_desc = 'SCORE_DESC',
  Popularity = 'POPULARITY',
  Popularity_desc = 'POPULARITY_DESC',
  Trending = 'TRENDING',
  Trending_desc = 'TRENDING_DESC',
  Episodes = 'EPISODES',
  Episodes_desc = 'EPISODES_DESC',
  Duration = 'DURATION',
  Duration_desc = 'DURATION_DESC',
  Status = 'STATUS',
  Status_desc = 'STATUS_DESC',
  Chapters = 'CHAPTERS',
  Chapters_desc = 'CHAPTERS_DESC',
  Volumes = 'VOLUMES',
  Volumes_desc = 'VOLUMES_DESC',
  Updated_at = 'UPDATED_AT',
  Updated_at_desc = 'UPDATED_AT_DESC',
  Search_match = 'SEARCH_MATCH',
  Favourites = 'FAVOURITES',
  Favourites_desc = 'FAVOURITES_DESC'
}
/** The primary language of the voice actor */
export enum IStaffLanguageModel {
  Japanese = 'JAPANESE',
  English = 'ENGLISH',
  Korean = 'KOREAN',
  Italian = 'ITALIAN',
  Spanish = 'SPANISH',
  Portuguese = 'PORTUGUESE',
  French = 'FRENCH',
  German = 'GERMAN',
  Hebrew = 'HEBREW',
  Hungarian = 'HUNGARIAN'
}
/** Staff sort enums */
export enum IStaffSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Role = 'ROLE',
  Role_desc = 'ROLE_DESC',
  Language = 'LANGUAGE',
  Language_desc = 'LANGUAGE_DESC',
  Search_match = 'SEARCH_MATCH',
  Favourites = 'FAVOURITES',
  Favourites_desc = 'FAVOURITES_DESC'
}
/** Studio sort enums */
export enum IStudioSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Name = 'NAME',
  Name_desc = 'NAME_DESC',
  Search_match = 'SEARCH_MATCH',
  Favourites = 'FAVOURITES',
  Favourites_desc = 'FAVOURITES_DESC'
}
/** Media trend sort enums */
export enum IMediaTrendSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Media_id = 'MEDIA_ID',
  Media_id_desc = 'MEDIA_ID_DESC',
  Date = 'DATE',
  Date_desc = 'DATE_DESC',
  Score = 'SCORE',
  Score_desc = 'SCORE_DESC',
  Popularity = 'POPULARITY',
  Popularity_desc = 'POPULARITY_DESC',
  Trending = 'TRENDING',
  Trending_desc = 'TRENDING_DESC',
  Episode = 'EPISODE',
  Episode_desc = 'EPISODE_DESC'
}
/** The type of ranking */
export enum IMediaRankTypeModel {
  Rated = 'RATED',
  Popular = 'POPULAR'
}
/** Media list watching/reading status enum. */
export enum IMediaListStatusModel {
  Current = 'CURRENT',
  Planning = 'PLANNING',
  Completed = 'COMPLETED',
  Dropped = 'DROPPED',
  Paused = 'PAUSED',
  Repeating = 'REPEATING'
}
/** Review sort enums */
export enum IReviewSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Score = 'SCORE',
  Score_desc = 'SCORE_DESC',
  Rating = 'RATING',
  Rating_desc = 'RATING_DESC',
  Created_at = 'CREATED_AT',
  Created_at_desc = 'CREATED_AT_DESC',
  Updated_at = 'UPDATED_AT',
  Updated_at_desc = 'UPDATED_AT_DESC'
}
/** Review rating enums */
export enum IReviewRatingModel {
  No_vote = 'NO_VOTE',
  Up_vote = 'UP_VOTE',
  Down_vote = 'DOWN_VOTE'
}
/** Recommendation sort enums */
export enum IRecommendationSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Rating = 'RATING',
  Rating_desc = 'RATING_DESC'
}
/** Recommendation rating enums */
export enum IRecommendationRatingModel {
  No_rating = 'NO_RATING',
  Rate_up = 'RATE_UP',
  Rate_down = 'RATE_DOWN'
}
/** Type of relation media has to its parent. */
export enum IMediaRelationModel {
  Adaptation = 'ADAPTATION',
  Prequel = 'PREQUEL',
  Sequel = 'SEQUEL',
  Parent = 'PARENT',
  Side_story = 'SIDE_STORY',
  Character = 'CHARACTER',
  Summary = 'SUMMARY',
  Alternative = 'ALTERNATIVE',
  Spin_off = 'SPIN_OFF',
  Other = 'OTHER',
  Source = 'SOURCE',
  Compilation = 'COMPILATION',
  Contains = 'CONTAINS'
}
/** User statistics sort enum */
export enum IUserStatisticsSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Count = 'COUNT',
  Count_desc = 'COUNT_DESC',
  Progress = 'PROGRESS',
  Progress_desc = 'PROGRESS_DESC',
  Mean_score = 'MEAN_SCORE',
  Mean_score_desc = 'MEAN_SCORE_DESC'
}
/** Media list sort enums */
export enum IMediaListSortModel {
  Media_id = 'MEDIA_ID',
  Media_id_desc = 'MEDIA_ID_DESC',
  Score = 'SCORE',
  Score_desc = 'SCORE_DESC',
  Status = 'STATUS',
  Status_desc = 'STATUS_DESC',
  Progress = 'PROGRESS',
  Progress_desc = 'PROGRESS_DESC',
  Progress_volumes = 'PROGRESS_VOLUMES',
  Progress_volumes_desc = 'PROGRESS_VOLUMES_DESC',
  Repeat = 'REPEAT',
  Repeat_desc = 'REPEAT_DESC',
  Priority = 'PRIORITY',
  Priority_desc = 'PRIORITY_DESC',
  Started_on = 'STARTED_ON',
  Started_on_desc = 'STARTED_ON_DESC',
  Finished_on = 'FINISHED_ON',
  Finished_on_desc = 'FINISHED_ON_DESC',
  Added_time = 'ADDED_TIME',
  Added_time_desc = 'ADDED_TIME_DESC',
  Updated_time = 'UPDATED_TIME',
  Updated_time_desc = 'UPDATED_TIME_DESC',
  Media_title_romaji = 'MEDIA_TITLE_ROMAJI',
  Media_title_romaji_desc = 'MEDIA_TITLE_ROMAJI_DESC',
  Media_title_english = 'MEDIA_TITLE_ENGLISH',
  Media_title_english_desc = 'MEDIA_TITLE_ENGLISH_DESC',
  Media_title_native = 'MEDIA_TITLE_NATIVE',
  Media_title_native_desc = 'MEDIA_TITLE_NATIVE_DESC',
  Media_popularity = 'MEDIA_POPULARITY',
  Media_popularity_desc = 'MEDIA_POPULARITY_DESC'
}
/** Airing schedule sort enums */
export enum IAiringSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Media_id = 'MEDIA_ID',
  Media_id_desc = 'MEDIA_ID_DESC',
  Time = 'TIME',
  Time_desc = 'TIME_DESC',
  Episode = 'EPISODE',
  Episode_desc = 'EPISODE_DESC'
}
/** Activity type enum. */
export enum IActivityTypeModel {
  Text = 'TEXT',
  Anime_list = 'ANIME_LIST',
  Manga_list = 'MANGA_LIST',
  Message = 'MESSAGE',
  Media_list = 'MEDIA_LIST'
}
/** Activity sort enums */
export enum IActivitySortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC'
}
/** Thread sort enums */
export enum IThreadSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC',
  Title = 'TITLE',
  Title_desc = 'TITLE_DESC',
  Created_at = 'CREATED_AT',
  Created_at_desc = 'CREATED_AT_DESC',
  Updated_at = 'UPDATED_AT',
  Updated_at_desc = 'UPDATED_AT_DESC',
  Replied_at = 'REPLIED_AT',
  Replied_at_desc = 'REPLIED_AT_DESC',
  Reply_count = 'REPLY_COUNT',
  Reply_count_desc = 'REPLY_COUNT_DESC',
  View_count = 'VIEW_COUNT',
  View_count_desc = 'VIEW_COUNT_DESC',
  Is_sticky = 'IS_STICKY',
  Search_match = 'SEARCH_MATCH'
}
/** Thread comments sort enums */
export enum IThreadCommentSortModel {
  Id = 'ID',
  Id_desc = 'ID_DESC'
}
/** Types that can be liked */
export enum ILikeableTypeModel {
  Thread = 'THREAD',
  Thread_comment = 'THREAD_COMMENT',
  Activity = 'ACTIVITY',
  Activity_reply = 'ACTIVITY_REPLY'
}
/** Site trend sort enums */
export enum ISiteTrendSortModel {
  Date = 'DATE',
  Date_desc = 'DATE_DESC',
  Count = 'COUNT',
  Count_desc = 'COUNT_DESC',
  Change = 'CHANGE',
  Change_desc = 'CHANGE_DESC'
}
/** Submission status */
export enum ISubmissionStatusModel {
  Pending = 'PENDING',
  Rejected = 'REJECTED',
  Partially_accepted = 'PARTIALLY_ACCEPTED',
  Accepted = 'ACCEPTED'
}
/** Revision history actions */
export enum IRevisionHistoryActionModel {
  Create = 'CREATE',
  Edit = 'EDIT'
}
export enum IModActionTypeModel {
  Note = 'NOTE',
  Ban = 'BAN',
  Delete = 'DELETE',
  Edit = 'EDIT',
  Expire = 'EXPIRE',
  Report = 'REPORT',
  Reset = 'RESET',
  Anon = 'ANON'
}
export interface IPageModelArgs {
  /** The page number*/
  page?: Maybe<number>;
  /** The amount of entries per page, max 50*/
  perPage?: Maybe<number>;
}

/** Media query */
export interface IMediaModelArgs {
  /** Filter by the media id*/
  id?: Maybe<number>;
  /** Filter by the media's MyAnimeList id*/
  idMal?: Maybe<number>;
  /** Filter by the start date of the media*/
  startDate?: Maybe<undefined>;
  /** Filter by the end date of the media*/
  endDate?: Maybe<undefined>;
  /** Filter by the season the media was released in*/
  season?: Maybe<IMediaSeasonModel>;
  /** The year of the season (Winter 2017 would also include December 2016 releases). Requires season argument*/
  seasonYear?: Maybe<number>;
  /** Filter by the media's type*/
  type?: Maybe<IMediaTypeModel>;
  /** Filter by the media's format*/
  format?: Maybe<IMediaFormatModel>;
  /** Filter by the media's current release status*/
  status?: Maybe<IMediaStatusModel>;
  /** Filter by amount of episodes the media has*/
  episodes?: Maybe<number>;
  /** Filter by the media's episode length*/
  duration?: Maybe<number>;
  /** Filter by the media's chapter count*/
  chapters?: Maybe<number>;
  /** Filter by the media's volume count*/
  volumes?: Maybe<number>;
  /** Filter by if the media's intended for 18+ adult audiences*/
  isAdult?: Maybe<boolean>;
  /** Filter by the media's genres*/
  genre?: Maybe<string>;
  /** Filter by the media's tags*/
  tag?: Maybe<string>;
  /** Only apply the tags filter argument to tags above this rank. Default: 18*/
  minimumTagRank?: Maybe<number>;
  /** Filter by the media's tags with in a tag category*/
  tagCategory?: Maybe<string>;
  /** Filter by the media on the authenticated user's lists*/
  onList?: Maybe<boolean>;
  /** Filter media by sites with a online streaming or reading license*/
  licensedBy?: Maybe<string>;
  /** Filter by the media's average score*/
  averageScore?: Maybe<number>;
  /** Filter by the number of users with this media on their list*/
  popularity?: Maybe<number>;
  /** Filter by the source type of the media*/
  source?: Maybe<IMediaSourceModel>;
  /** Filter by the media's country of origin*/
  countryOfOrigin?: Maybe<undefined>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** Filter by the media id*/
  id_not?: Maybe<number>;
  /** Filter by the media id*/
  id_in?: Maybe<number[]>;
  /** Filter by the media id*/
  id_not_in?: Maybe<number[]>;
  /** Filter by the media's MyAnimeList id*/
  idMal_not?: Maybe<number>;
  /** Filter by the media's MyAnimeList id*/
  idMal_in?: Maybe<number[]>;
  /** Filter by the media's MyAnimeList id*/
  idMal_not_in?: Maybe<number[]>;
  /** Filter by the start date of the media*/
  startDate_greater?: Maybe<undefined>;
  /** Filter by the start date of the media*/
  startDate_lesser?: Maybe<undefined>;
  /** Filter by the start date of the media*/
  startDate_like?: Maybe<string>;
  /** Filter by the end date of the media*/
  endDate_greater?: Maybe<undefined>;
  /** Filter by the end date of the media*/
  endDate_lesser?: Maybe<undefined>;
  /** Filter by the end date of the media*/
  endDate_like?: Maybe<string>;
  /** Filter by the media's format*/
  format_in?: Maybe<IMediaFormatModel[]>;
  /** Filter by the media's format*/
  format_not?: Maybe<IMediaFormatModel>;
  /** Filter by the media's format*/
  format_not_in?: Maybe<IMediaFormatModel[]>;
  /** Filter by the media's current release status*/
  status_in?: Maybe<IMediaStatusModel[]>;
  /** Filter by the media's current release status*/
  status_not?: Maybe<IMediaStatusModel>;
  /** Filter by the media's current release status*/
  status_not_in?: Maybe<IMediaStatusModel[]>;
  /** Filter by amount of episodes the media has*/
  episodes_greater?: Maybe<number>;
  /** Filter by amount of episodes the media has*/
  episodes_lesser?: Maybe<number>;
  /** Filter by the media's episode length*/
  duration_greater?: Maybe<number>;
  /** Filter by the media's episode length*/
  duration_lesser?: Maybe<number>;
  /** Filter by the media's chapter count*/
  chapters_greater?: Maybe<number>;
  /** Filter by the media's chapter count*/
  chapters_lesser?: Maybe<number>;
  /** Filter by the media's volume count*/
  volumes_greater?: Maybe<number>;
  /** Filter by the media's volume count*/
  volumes_lesser?: Maybe<number>;
  /** Filter by the media's genres*/
  genre_in?: Maybe<string[]>;
  /** Filter by the media's genres*/
  genre_not_in?: Maybe<string[]>;
  /** Filter by the media's tags*/
  tag_in?: Maybe<string[]>;
  /** Filter by the media's tags*/
  tag_not_in?: Maybe<string[]>;
  /** Filter by the media's tags with in a tag category*/
  tagCategory_in?: Maybe<string[]>;
  /** Filter by the media's tags with in a tag category*/
  tagCategory_not_in?: Maybe<string[]>;
  /** Filter media by sites with a online streaming or reading license*/
  licensedBy_in?: Maybe<string[]>;
  /** Filter by the media's average score*/
  averageScore_not?: Maybe<number>;
  /** Filter by the media's average score*/
  averageScore_greater?: Maybe<number>;
  /** Filter by the media's average score*/
  averageScore_lesser?: Maybe<number>;
  /** Filter by the number of users with this media on their list*/
  popularity_not?: Maybe<number>;
  /** Filter by the number of users with this media on their list*/
  popularity_greater?: Maybe<number>;
  /** Filter by the number of users with this media on their list*/
  popularity_lesser?: Maybe<number>;
  /** Filter by the source type of the media*/
  source_in?: Maybe<IMediaSourceModel[]>;
  /** The order the results will be returned in*/
  sort?: Maybe<IMediaSortModel[]>;
}

/** Media Trend query */
export interface IMediaTrendModelArgs {
  /** Filter by the media id*/
  mediaId?: Maybe<number>;
  /** Filter by date*/
  date?: Maybe<number>;
  /** Filter by trending amount*/
  trending?: Maybe<number>;
  /** Filter by score*/
  averageScore?: Maybe<number>;
  /** Filter by popularity*/
  popularity?: Maybe<number>;
  /** Filter by episode number*/
  episode?: Maybe<number>;
  /** Filter to stats recorded while the media was releasing*/
  releasing?: Maybe<boolean>;
  /** Filter by the media id*/
  mediaId_not?: Maybe<number>;
  /** Filter by the media id*/
  mediaId_in?: Maybe<number[]>;
  /** Filter by the media id*/
  mediaId_not_in?: Maybe<number[]>;
  /** Filter by date*/
  date_greater?: Maybe<number>;
  /** Filter by date*/
  date_lesser?: Maybe<number>;
  /** Filter by trending amount*/
  trending_greater?: Maybe<number>;
  /** Filter by trending amount*/
  trending_lesser?: Maybe<number>;
  /** Filter by trending amount*/
  trending_not?: Maybe<number>;
  /** Filter by score*/
  averageScore_greater?: Maybe<number>;
  /** Filter by score*/
  averageScore_lesser?: Maybe<number>;
  /** Filter by score*/
  averageScore_not?: Maybe<number>;
  /** Filter by popularity*/
  popularity_greater?: Maybe<number>;
  /** Filter by popularity*/
  popularity_lesser?: Maybe<number>;
  /** Filter by popularity*/
  popularity_not?: Maybe<number>;
  /** Filter by episode number*/
  episode_greater?: Maybe<number>;
  /** Filter by episode number*/
  episode_lesser?: Maybe<number>;
  /** Filter by episode number*/
  episode_not?: Maybe<number>;
  /** The order the results will be returned in*/
  sort?: Maybe<IMediaTrendSortModel[]>;
}

/** Airing schedule query */
export interface IAiringScheduleModelArgs {
  /** Filter by the id of the airing schedule item*/
  id?: Maybe<number>;
  /** Filter by the id of associated media*/
  mediaId?: Maybe<number>;
  /** Filter by the airing episode number*/
  episode?: Maybe<number>;
  /** Filter by the time of airing*/
  airingAt?: Maybe<number>;
  /** Filter to episodes that haven't yet aired*/
  notYetAired?: Maybe<boolean>;
  /** Filter by the id of the airing schedule item*/
  id_not?: Maybe<number>;
  /** Filter by the id of the airing schedule item*/
  id_in?: Maybe<number[]>;
  /** Filter by the id of the airing schedule item*/
  id_not_in?: Maybe<number[]>;
  /** Filter by the id of associated media*/
  mediaId_not?: Maybe<number>;
  /** Filter by the id of associated media*/
  mediaId_in?: Maybe<number[]>;
  /** Filter by the id of associated media*/
  mediaId_not_in?: Maybe<number[]>;
  /** Filter by the airing episode number*/
  episode_not?: Maybe<number>;
  /** Filter by the airing episode number*/
  episode_in?: Maybe<number[]>;
  /** Filter by the airing episode number*/
  episode_not_in?: Maybe<number[]>;
  /** Filter by the airing episode number*/
  episode_greater?: Maybe<number>;
  /** Filter by the airing episode number*/
  episode_lesser?: Maybe<number>;
  /** Filter by the time of airing*/
  airingAt_greater?: Maybe<number>;
  /** Filter by the time of airing*/
  airingAt_lesser?: Maybe<number>;
  /** The order the results will be returned in*/
  sort?: Maybe<IAiringSortModel[]>;
}

/** Character query */
export interface ICharacterModelArgs {
  /** Filter by character id*/
  id?: Maybe<number>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** Filter by character id*/
  id_not?: Maybe<number>;
  /** Filter by character id*/
  id_in?: Maybe<number[]>;
  /** Filter by character id*/
  id_not_in?: Maybe<number[]>;
  /** The order the results will be returned in*/
  sort?: Maybe<ICharacterSortModel[]>;
}

/** Staff query */
export interface IStaffModelArgs {
  /** Filter by the staff id*/
  id?: Maybe<number>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** Filter by the staff id*/
  id_not?: Maybe<number>;
  /** Filter by the staff id*/
  id_in?: Maybe<number[]>;
  /** Filter by the staff id*/
  id_not_in?: Maybe<number[]>;
  /** The order the results will be returned in*/
  sort?: Maybe<IStaffSortModel[]>;
}

/** Media list query */
export interface IMediaListModelArgs {
  /** Filter by a list entry's id*/
  id?: Maybe<number>;
  /** Filter by a user's id*/
  userId?: Maybe<number>;
  /** Filter by a user's name*/
  userName?: Maybe<string>;
  /** Filter by the list entries media type*/
  type?: Maybe<IMediaTypeModel>;
  /** Filter by the watching/reading status*/
  status?: Maybe<IMediaListStatusModel>;
  /** Filter by the media id of the list entry*/
  mediaId?: Maybe<number>;
  /** Filter list entries to users who are being followed by the authenticated user*/
  isFollowing?: Maybe<boolean>;
  /** Filter by note words and #tags*/
  notes?: Maybe<string>;
  /** Filter by the date the user started the media*/
  startedAt?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt?: Maybe<undefined>;
  /** Limit to only entries also on the auth user's list. Requires user id or name arguments.*/
  compareWithAuthList?: Maybe<boolean>;
  /** Filter by a user's id*/
  userId_in?: Maybe<number[]>;
  /** Filter by the watching/reading status*/
  status_in?: Maybe<IMediaListStatusModel[]>;
  /** Filter by the watching/reading status*/
  status_not_in?: Maybe<IMediaListStatusModel[]>;
  /** Filter by the watching/reading status*/
  status_not?: Maybe<IMediaListStatusModel>;
  /** Filter by the media id of the list entry*/
  mediaId_in?: Maybe<number[]>;
  /** Filter by the media id of the list entry*/
  mediaId_not_in?: Maybe<number[]>;
  /** Filter by note words and #tags*/
  notes_like?: Maybe<string>;
  /** Filter by the date the user started the media*/
  startedAt_greater?: Maybe<undefined>;
  /** Filter by the date the user started the media*/
  startedAt_lesser?: Maybe<undefined>;
  /** Filter by the date the user started the media*/
  startedAt_like?: Maybe<string>;
  /** Filter by the date the user completed the media*/
  completedAt_greater?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt_lesser?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt_like?: Maybe<string>;
  /** The order the results will be returned in*/
  sort?: Maybe<IMediaListSortModel[]>;
}

/** Media list collection query, provides list pre-grouped by status & custom lists. User ID and Media Type arguments required. */
export interface IMediaListCollectionModelArgs {
  /** Filter by a user's id*/
  userId?: Maybe<number>;
  /** Filter by a user's name*/
  userName?: Maybe<string>;
  /** Filter by the list entries media type*/
  type?: Maybe<IMediaTypeModel>;
  /** Filter by the watching/reading status*/
  status?: Maybe<IMediaListStatusModel>;
  /** Filter by note words and #tags*/
  notes?: Maybe<string>;
  /** Filter by the date the user started the media*/
  startedAt?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt?: Maybe<undefined>;
  /** Always return completed list entries in one group, overriding the user's split completed option.*/
  forceSingleCompletedList?: Maybe<boolean>;
  /** Which chunk of list entries to load*/
  chunk?: Maybe<number>;
  /** The amount of entries per chunk, max 500*/
  perChunk?: Maybe<number>;
  /** Filter by the watching/reading status*/
  status_in?: Maybe<IMediaListStatusModel[]>;
  /** Filter by the watching/reading status*/
  status_not_in?: Maybe<IMediaListStatusModel[]>;
  /** Filter by the watching/reading status*/
  status_not?: Maybe<IMediaListStatusModel>;
  /** Filter by note words and #tags*/
  notes_like?: Maybe<string>;
  /** Filter by the date the user started the media*/
  startedAt_greater?: Maybe<undefined>;
  /** Filter by the date the user started the media*/
  startedAt_lesser?: Maybe<undefined>;
  /** Filter by the date the user started the media*/
  startedAt_like?: Maybe<string>;
  /** Filter by the date the user completed the media*/
  completedAt_greater?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt_lesser?: Maybe<undefined>;
  /** Filter by the date the user completed the media*/
  completedAt_like?: Maybe<string>;
  /** The order the results will be returned in*/
  sort?: Maybe<IMediaListSortModel[]>;
}

/** Collection of all the possible media genres */
export interface IGenreCollectionModelArgs {}

/** Collection of all the possible media tags */
export interface IMediaTagCollectionModelArgs {
  /** Mod Only*/
  status?: Maybe<number>;
}

/** User query */
export interface IUserModelArgs {
  /** Filter by the user id*/
  id?: Maybe<number>;
  /** Filter by the name of the user*/
  name?: Maybe<string>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** The order the results will be returned in*/
  sort?: Maybe<IUserSortModel[]>;
}

/** Get the currently authenticated user */
export interface IViewerModelArgs {}

/** Notification query */
export interface INotificationModelArgs {
  /** Filter by the type of notifications*/
  type?: Maybe<INotificationTypeModel>;
  /** Reset the unread notification count to 0 on load*/
  resetNotificationCount?: Maybe<boolean>;
  /** Filter by the type of notifications*/
  type_in?: Maybe<INotificationTypeModel[]>;
}

/** Studio query */
export interface IStudioModelArgs {
  /** Filter by the studio id*/
  id?: Maybe<number>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** Filter by the studio id*/
  id_not?: Maybe<number>;
  /** Filter by the studio id*/
  id_in?: Maybe<number[]>;
  /** Filter by the studio id*/
  id_not_in?: Maybe<number[]>;
  /** The order the results will be returned in*/
  sort?: Maybe<IStudioSortModel[]>;
}

/** Review query */
export interface IReviewModelArgs {
  /** Filter by Review id*/
  id?: Maybe<number>;
  /** Filter by media id*/
  mediaId?: Maybe<number>;
  /** Filter by media id*/
  userId?: Maybe<number>;
  /** Filter by media type*/
  mediaType?: Maybe<IMediaTypeModel>;
  /** The order the results will be returned in*/
  sort?: Maybe<IReviewSortModel[]>;
}

/** Activity query */
export interface IActivityModelArgs {
  /** Filter by the activity id*/
  id?: Maybe<number>;
  /** Filter by the owner user id*/
  userId?: Maybe<number>;
  /** Filter by the id of the user who sent a message*/
  messengerId?: Maybe<number>;
  /** Filter by the associated media id of the activity*/
  mediaId?: Maybe<number>;
  /** Filter by the type of activity*/
  type?: Maybe<IActivityTypeModel>;
  /** Filter activity to users who are being followed by the authenticated user*/
  isFollowing?: Maybe<boolean>;
  /** Filter activity to only activity with replies*/
  hasReplies?: Maybe<boolean>;
  /** Filter activity to only activity with replies or is of type text*/
  hasRepliesOrTypeText?: Maybe<boolean>;
  /** Filter by the time the activity was created*/
  createdAt?: Maybe<number>;
  /** Filter by the activity id*/
  id_not?: Maybe<number>;
  /** Filter by the activity id*/
  id_in?: Maybe<number[]>;
  /** Filter by the activity id*/
  id_not_in?: Maybe<number[]>;
  /** Filter by the owner user id*/
  userId_not?: Maybe<number>;
  /** Filter by the owner user id*/
  userId_in?: Maybe<number[]>;
  /** Filter by the owner user id*/
  userId_not_in?: Maybe<number[]>;
  /** Filter by the id of the user who sent a message*/
  messengerId_not?: Maybe<number>;
  /** Filter by the id of the user who sent a message*/
  messengerId_in?: Maybe<number[]>;
  /** Filter by the id of the user who sent a message*/
  messengerId_not_in?: Maybe<number[]>;
  /** Filter by the associated media id of the activity*/
  mediaId_not?: Maybe<number>;
  /** Filter by the associated media id of the activity*/
  mediaId_in?: Maybe<number[]>;
  /** Filter by the associated media id of the activity*/
  mediaId_not_in?: Maybe<number[]>;
  /** Filter by the type of activity*/
  type_not?: Maybe<IActivityTypeModel>;
  /** Filter by the type of activity*/
  type_in?: Maybe<IActivityTypeModel[]>;
  /** Filter by the type of activity*/
  type_not_in?: Maybe<IActivityTypeModel[]>;
  /** Filter by the time the activity was created*/
  createdAt_greater?: Maybe<number>;
  /** Filter by the time the activity was created*/
  createdAt_lesser?: Maybe<number>;
  /** The order the results will be returned in*/
  sort?: Maybe<IActivitySortModel[]>;
}

/** Activity reply query */
export interface IActivityReplyModelArgs {
  /** Filter by the reply id*/
  id?: Maybe<number>;
  /** Filter by the parent id*/
  activityId?: Maybe<number>;
}

/** Follow query */
export interface IFollowingModelArgs {
  /** User id of the follower/followed*/
  userId: number;
  /** The order the results will be returned in*/
  sort?: Maybe<IUserSortModel[]>;
}

/** Follow query */
export interface IFollowerModelArgs {
  /** User id of the follower/followed*/
  userId: number;
  /** The order the results will be returned in*/
  sort?: Maybe<IUserSortModel[]>;
}

/** Thread query */
export interface IThreadModelArgs {
  /** Filter by the thread id*/
  id?: Maybe<number>;
  /** Filter by the user id of the thread's creator*/
  userId?: Maybe<number>;
  /** Filter by the user id of the last user to comment on the thread*/
  replyUserId?: Maybe<number>;
  /** Filter by if the currently authenticated user's subscribed threads*/
  subscribed?: Maybe<boolean>;
  /** Filter by thread category id*/
  categoryId?: Maybe<number>;
  /** Filter by thread media id category*/
  mediaCategoryId?: Maybe<number>;
  /** Filter by search query*/
  search?: Maybe<string>;
  /** Filter by the thread id*/
  id_in?: Maybe<number[]>;
  /** The order the results will be returned in*/
  sort?: Maybe<IThreadSortModel[]>;
}

/** Comment query */
export interface IThreadCommentModelArgs {
  /** Filter by the comment id*/
  id?: Maybe<number>;
  /** Filter by the thread id*/
  threadId?: Maybe<number>;
  /** Filter by the user id of the comment's creator*/
  userId?: Maybe<number>;
  /** The order the results will be returned in*/
  sort?: Maybe<IThreadCommentSortModel[]>;
}

/** Recommendation query */
export interface IRecommendationModelArgs {
  /** Filter by recommendation id*/
  id?: Maybe<number>;
  /** Filter by media id*/
  mediaId?: Maybe<number>;
  /** Filter by media recommendation id*/
  mediaRecommendationId?: Maybe<number>;
  /** Filter by user who created the recommendation*/
  userId?: Maybe<number>;
  /** Filter by total rating of the recommendation*/
  rating?: Maybe<number>;
  /** Filter by the media on the authenticated user's lists*/
  onList?: Maybe<boolean>;
  /** Filter by total rating of the recommendation*/
  rating_greater?: Maybe<number>;
  /** Filter by total rating of the recommendation*/
  rating_lesser?: Maybe<number>;
  /** The order the results will be returned in*/
  sort?: Maybe<IRecommendationSortModel[]>;
}

/** Like query */
export interface ILikeModelArgs {
  /** The id of the likeable type*/
  likeableId?: Maybe<number>;
  /** The type of model the id applies to*/
  type?: Maybe<ILikeableTypeModel>;
}

/** Provide AniList markdown to be converted to html (Requires auth) */
export interface IMarkdownModelArgs {
  /** The markdown to be parsed to html*/
  markdown: string;
}

export interface IAniChartUserModelArgs {}

/** Site statistics query */
export interface ISiteStatisticsModelArgs {}

export interface IUpdateUserModelArgs {
  /** User's about/bio text*/
  about?: Maybe<string>;
  /** User's title language*/
  titleLanguage?: Maybe<IUserTitleLanguageModel>;
  /** If the user should see media marked as adult-only*/
  displayAdultContent?: Maybe<boolean>;
  /** If the user should get notifications when a show they are watching aires*/
  airingNotifications?: Maybe<boolean>;
  /** The user's list scoring system*/
  scoreFormat?: Maybe<IScoreFormatModel>;
  /** The user's default list order*/
  rowOrder?: Maybe<string>;
  /** Profile highlight color*/
  profileColor?: Maybe<string>;
  /** Profile highlight color*/
  donatorBadge?: Maybe<string>;
  /** Notification options*/
  notificationOptions?: Maybe<INotificationOptionInputModel[]>;
  /** The user's anime list options*/
  animeListOptions?: Maybe<IMediaListOptionsInputModel>;
  /** The user's anime list options*/
  mangaListOptions?: Maybe<IMediaListOptionsInputModel>;
}

/** Create or update a media list entry */
export interface ISaveMediaListEntryModelArgs {
  /** The list entry id, required for updating*/
  id?: Maybe<number>;
  /** The id of the media the entry is of*/
  mediaId?: Maybe<number>;
  /** The watching/reading status*/
  status?: Maybe<IMediaListStatusModel>;
  /** The score of the media in the user's chosen scoring method*/
  score?: Maybe<number>;
  /** The score of the media in 100 point*/
  scoreRaw?: Maybe<number>;
  /** The amount of episodes/chapters consumed by the user*/
  progress?: Maybe<number>;
  /** The amount of volumes read by the user*/
  progressVolumes?: Maybe<number>;
  /** The amount of times the user has rewatched/read the media*/
  repeat?: Maybe<number>;
  /** Priority of planning*/
  priority?: Maybe<number>;
  /** If the entry should only be visible to authenticated user*/
  private?: Maybe<boolean>;
  /** Text notes*/
  notes?: Maybe<string>;
  /** If the entry shown be hidden from non-custom lists*/
  hiddenFromStatusLists?: Maybe<boolean>;
  /** Array of custom list names which should be enabled for this entry*/
  customLists?: Maybe<string[]>;
  /** Array of advanced scores*/
  advancedScores?: Maybe<number[]>;
  /** When the entry was started by the user*/
  startedAt?: Maybe<IFuzzyDateInputModel>;
  /** When the entry was completed by the user*/
  completedAt?: Maybe<IFuzzyDateInputModel>;
}

/** Update multiple media list entries to the same values */
export interface IUpdateMediaListEntriesModelArgs {
  /** The watching/reading status*/
  status?: Maybe<IMediaListStatusModel>;
  /** The score of the media in the user's chosen scoring method*/
  score?: Maybe<number>;
  /** The score of the media in 100 point*/
  scoreRaw?: Maybe<number>;
  /** The amount of episodes/chapters consumed by the user*/
  progress?: Maybe<number>;
  /** The amount of volumes read by the user*/
  progressVolumes?: Maybe<number>;
  /** The amount of times the user has rewatched/read the media*/
  repeat?: Maybe<number>;
  /** Priority of planning*/
  priority?: Maybe<number>;
  /** If the entry should only be visible to authenticated user*/
  private?: Maybe<boolean>;
  /** Text notes*/
  notes?: Maybe<string>;
  /** If the entry shown be hidden from non-custom lists*/
  hiddenFromStatusLists?: Maybe<boolean>;
  /** Array of advanced scores*/
  advancedScores?: Maybe<number[]>;
  /** When the entry was started by the user*/
  startedAt?: Maybe<IFuzzyDateInputModel>;
  /** When the entry was completed by the user*/
  completedAt?: Maybe<IFuzzyDateInputModel>;
  /** The list entries ids to update*/
  ids?: Maybe<number[]>;
}

/** Delete a media list entry */
export interface IDeleteMediaListEntryModelArgs {
  /** The id of the media list entry to delete*/
  id?: Maybe<number>;
}

/** Delete a custom list and remove the list entries from it */
export interface IDeleteCustomListModelArgs {
  /** The name of the custom list to delete*/
  customList?: Maybe<string>;
  /** The media list type of the custom list*/
  type?: Maybe<IMediaTypeModel>;
}

/** Create or update text activity for the currently authenticated user */
export interface ISaveTextActivityModelArgs {
  /** The activity's id, required for updating*/
  id?: Maybe<number>;
  /** The activity text*/
  text?: Maybe<string>;
  /** If the activity should be locked. (Mod Only)*/
  locked?: Maybe<boolean>;
}

/** Create or update message activity for the currently authenticated user */
export interface ISaveMessageActivityModelArgs {
  /** The activity id, required for updating*/
  id?: Maybe<number>;
  /** The activity message text*/
  message?: Maybe<string>;
  /** The id of the user the message is being sent to*/
  recipientId?: Maybe<number>;
  /** If the activity should be private*/
  private?: Maybe<boolean>;
  /** If the activity should be locked. (Mod Only)*/
  locked?: Maybe<boolean>;
  /** If the message should be sent from the Moderator account (Mod Only)*/
  asMod?: Maybe<boolean>;
}

/** Update list activity (Mod Only) */
export interface ISaveListActivityModelArgs {
  /** The activity's id, required for updating*/
  id?: Maybe<number>;
  /** If the activity should be locked. (Mod Only)*/
  locked?: Maybe<boolean>;
}

/** Delete an activity item of the authenticated users */
export interface IDeleteActivityModelArgs {
  /** The id of the activity to delete*/
  id?: Maybe<number>;
}

/** Toggle the subscription of an activity item */
export interface IToggleActivitySubscriptionModelArgs {
  /** The id of the activity to un/subscribe*/
  activityId?: Maybe<number>;
  /** Whether to subscribe or unsubscribe from the activity*/
  subscribe?: Maybe<boolean>;
}

/** Create or update an activity reply */
export interface ISaveActivityReplyModelArgs {
  /** The activity reply id, required for updating*/
  id?: Maybe<number>;
  /** The id of the parent activity being replied to*/
  activityId?: Maybe<number>;
  /** The reply text*/
  text?: Maybe<string>;
  /** If the reply should be sent from the Moderator account (Mod Only)*/
  asMod?: Maybe<boolean>;
}

/** Delete an activity reply of the authenticated users */
export interface IDeleteActivityReplyModelArgs {
  /** The id of the reply to delete*/
  id?: Maybe<number>;
}

/** Add or remove a like from a likeable type.
                          Returns all the users who liked the same model */
export interface IToggleLikeModelArgs {
  /** The id of the likeable type*/
  id?: Maybe<number>;
  /** The type of model to be un/liked*/
  type?: Maybe<ILikeableTypeModel>;
}

/** Add or remove a like from a likeable type. */
export interface IToggleLikeV2ModelArgs {
  /** The id of the likeable type*/
  id?: Maybe<number>;
  /** The type of model to be un/liked*/
  type?: Maybe<ILikeableTypeModel>;
}

/** Toggle the un/following of a user */
export interface IToggleFollowModelArgs {
  /** The id of the user to un/follow*/
  userId?: Maybe<number>;
}

/** Favourite or unfavourite an anime, manga, character, staff member, or studio */
export interface IToggleFavouriteModelArgs {
  /** The id of the anime to un/favourite*/
  animeId?: Maybe<number>;
  /** The id of the manga to un/favourite*/
  mangaId?: Maybe<number>;
  /** The id of the character to un/favourite*/
  characterId?: Maybe<number>;
  /** The id of the staff to un/favourite*/
  staffId?: Maybe<number>;
  /** The id of the studio to un/favourite*/
  studioId?: Maybe<number>;
}

/** Update the order favourites are displayed in */
export interface IUpdateFavouriteOrderModelArgs {
  /** The id of the anime to un/favourite*/
  animeIds?: Maybe<number[]>;
  /** The id of the manga to un/favourite*/
  mangaIds?: Maybe<number[]>;
  /** The id of the character to un/favourite*/
  characterIds?: Maybe<number[]>;
  /** The id of the staff to un/favourite*/
  staffIds?: Maybe<number[]>;
  /** The id of the studio to un/favourite*/
  studioIds?: Maybe<number[]>;
  /** List of integers which the anime should be ordered by (Asc)*/
  animeOrder?: Maybe<number[]>;
  /** List of integers which the manga should be ordered by (Asc)*/
  mangaOrder?: Maybe<number[]>;
  /** List of integers which the character should be ordered by (Asc)*/
  characterOrder?: Maybe<number[]>;
  /** List of integers which the staff should be ordered by (Asc)*/
  staffOrder?: Maybe<number[]>;
  /** List of integers which the studio should be ordered by (Asc)*/
  studioOrder?: Maybe<number[]>;
}

/** Create or update a review */
export interface ISaveReviewModelArgs {
  /** The review id, required for updating*/
  id?: Maybe<number>;
  /** The id of the media the review is of*/
  mediaId?: Maybe<number>;
  /** The main review text. Min:2200 characters*/
  body?: Maybe<string>;
  /** A short summary/preview of the review. Min:20, Max:120 characters*/
  summary?: Maybe<string>;
  /** A short summary/preview of the review. Min:20, Max:120 characters*/
  score?: Maybe<number>;
  /** If the review should only be visible to its creator*/
  private?: Maybe<boolean>;
}

/** Delete a review */
export interface IDeleteReviewModelArgs {
  /** The id of the review to delete*/
  id?: Maybe<number>;
}

/** Rate a review */
export interface IRateReviewModelArgs {
  /** The id of the review to rate*/
  reviewId?: Maybe<number>;
  /** The rating to apply to the review*/
  rating?: Maybe<IReviewRatingModel>;
}

/** Recommendation a media */
export interface ISaveRecommendationModelArgs {
  /** The id of the base media*/
  mediaId?: Maybe<number>;
  /** The id of the media to recommend*/
  mediaRecommendationId?: Maybe<number>;
  /** The rating to give the recommendation*/
  rating?: Maybe<IRecommendationRatingModel>;
}

/** Create or update a forum thread */
export interface ISaveThreadModelArgs {
  /** The thread id, required for updating*/
  id?: Maybe<number>;
  /** The title of the thread*/
  title?: Maybe<string>;
  /** The main text body of the thread*/
  body?: Maybe<string>;
  /** Forum categories the thread should be within*/
  categories?: Maybe<number[]>;
  /** Media related to the contents of the thread*/
  mediaCategories?: Maybe<number[]>;
  /** If the thread should be stickied. (Mod Only)*/
  sticky?: Maybe<boolean>;
  /** If the thread should be locked. (Mod Only)*/
  locked?: Maybe<boolean>;
}

/** Delete a thread */
export interface IDeleteThreadModelArgs {
  /** The id of the thread to delete*/
  id?: Maybe<number>;
}

/** Toggle the subscription of a forum thread */
export interface IToggleThreadSubscriptionModelArgs {
  /** The id of the forum thread to un/subscribe*/
  threadId?: Maybe<number>;
  /** Whether to subscribe or unsubscribe from the forum thread*/
  subscribe?: Maybe<boolean>;
}

/** Create or update a thread comment */
export interface ISaveThreadCommentModelArgs {
  /** The comment id, required for updating*/
  id?: Maybe<number>;
  /** The id of thread the comment belongs to*/
  threadId?: Maybe<number>;
  /** The id of thread comment to reply to*/
  parentCommentId?: Maybe<number>;
  /** The comment markdown text*/
  comment?: Maybe<string>;
}

/** Delete a thread comment */
export interface IDeleteThreadCommentModelArgs {
  /** The id of the thread comment to delete*/
  id?: Maybe<number>;
}

export interface IUpdateAniChartSettingsModelArgs {
  titleLanguage?: Maybe<string>;
  outgoingLinkProvider?: Maybe<string>;
  theme?: Maybe<string>;
  sort?: Maybe<string>;
}

export interface IUpdateAniChartHighlightsModelArgs {
  highlights?: Maybe<IAniChartHighlightInputModel[]>;
}

import { OperationDefinitionNode, DocumentNode } from 'graphql';
import sgtsQL from 'graphql-tag';

const guessFragmentType = (fragment: string | DocumentNode) => {
  let isString,
    isFragment = false;
  let fragmentName = '';
  if (typeof fragment === 'string') {
    isString = true;
  } else if (typeof fragment === 'object' && fragment.definitions.length) {
    isFragment = true;
    const definition = fragment.definitions[0];
    if (definition.kind === 'FragmentDefinition') {
      fragmentName = definition.name.value;
    } else {
      console.error(
        \`The argument passed is not a fragment definition, got \${definition.kind} instead\`
      );
      return;
    }
  }
  return { isString, isFragment, fragmentName };
};

import ApolloClient, {
  QueryOptions,
  OperationVariables,
  MutationOptions,
  ObservableQuery
} from 'apollo-client';
import { execute } from 'apollo-link';

export type AbortableQueryWithArgs<T, A> = {
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQueryWithOptionalArgs<T, A> = {
  $fetch(): Promise<T>;
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQuery<T> = {
  $fetch(): Promise<T>;
  $abort(): void;
};
export interface FragmentableQueryWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithArgs<T, A>;
}
export interface FragmentableQueryWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithOptionalArgs<T, A>;
}
export interface FragmentableQuery<T> {
  $fragment(fragment: string | DocumentNode): AbortableQuery<T>;
}

export type AbortableMutationWithArgs<T, A> = {
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutationWithOptionalArgs<T, A> = {
  $post(): Promise<T>;
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutation<T> = {
  $post(): Promise<T>;
  $abort(): void;
};

export interface FragmentableMutationWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithArgs<T, A>;
}
export interface FragmentableMutationWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithOptionalArgs<T, A>;
}
export interface FragmentableMutation<T> {
  $fragment(fragment: string | DocumentNode): AbortableMutation<T>;
}

export const apiProvider = (apolloClient: ApolloClient<any>) => {
  const abortableQuery = <T, A = null>(
    query: DocumentNode,
    args: boolean
  ): A extends null ? AbortableQuery<T> : AbortableQueryWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = query.definitions[0] as OperationDefinitionNode;
    const queryName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $fetch() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[queryName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $fetch
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $fetch
      } as any;
    }
  };
  const abortableMutation = <T, A = null>(
    mutation: DocumentNode,
    args: boolean
  ): AbortableMutationWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = mutation.definitions[0] as OperationDefinitionNode;
    const mutationName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $post() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query: mutation,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[mutationName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $post
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $post
      } as any;
    }
  };

  return {
    Page(): FragmentableQueryWithOptionalArgs<IPageModel, IPageArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Page ($page: Int,$perPage: Int) {
        Page(page: $page,perPage: $perPage) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Media query */
    Media(): FragmentableQueryWithOptionalArgs<IMediaModel, IMediaArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Media ($id: Int,$idMal: Int,$startDate: FuzzyDateInt,$endDate: FuzzyDateInt,$season: MediaSeason,$seasonYear: Int,$type: MediaType,$format: MediaFormat,$status: MediaStatus,$episodes: Int,$duration: Int,$chapters: Int,$volumes: Int,$isAdult: Boolean,$genre: String,$tag: String,$minimumTagRank: Int,$tagCategory: String,$onList: Boolean,$licensedBy: String,$averageScore: Int,$popularity: Int,$source: MediaSource,$countryOfOrigin: CountryCode,$search: String,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$idMal_not: Int,$idMal_in: [Int]!,$idMal_not_in: [Int]!,$startDate_greater: FuzzyDateInt,$startDate_lesser: FuzzyDateInt,$startDate_like: String,$endDate_greater: FuzzyDateInt,$endDate_lesser: FuzzyDateInt,$endDate_like: String,$format_in: [MediaFormat]!,$format_not: MediaFormat,$format_not_in: [MediaFormat]!,$status_in: [MediaStatus]!,$status_not: MediaStatus,$status_not_in: [MediaStatus]!,$episodes_greater: Int,$episodes_lesser: Int,$duration_greater: Int,$duration_lesser: Int,$chapters_greater: Int,$chapters_lesser: Int,$volumes_greater: Int,$volumes_lesser: Int,$genre_in: [String]!,$genre_not_in: [String]!,$tag_in: [String]!,$tag_not_in: [String]!,$tagCategory_in: [String]!,$tagCategory_not_in: [String]!,$licensedBy_in: [String]!,$averageScore_not: Int,$averageScore_greater: Int,$averageScore_lesser: Int,$popularity_not: Int,$popularity_greater: Int,$popularity_lesser: Int,$source_in: [MediaSource]!,$sort: [MediaSort]!) {
        Media(id: $id,idMal: $idMal,startDate: $startDate,endDate: $endDate,season: $season,seasonYear: $seasonYear,type: $type,format: $format,status: $status,episodes: $episodes,duration: $duration,chapters: $chapters,volumes: $volumes,isAdult: $isAdult,genre: $genre,tag: $tag,minimumTagRank: $minimumTagRank,tagCategory: $tagCategory,onList: $onList,licensedBy: $licensedBy,averageScore: $averageScore,popularity: $popularity,source: $source,countryOfOrigin: $countryOfOrigin,search: $search,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,idMal_not: $idMal_not,idMal_in: $idMal_in,idMal_not_in: $idMal_not_in,startDate_greater: $startDate_greater,startDate_lesser: $startDate_lesser,startDate_like: $startDate_like,endDate_greater: $endDate_greater,endDate_lesser: $endDate_lesser,endDate_like: $endDate_like,format_in: $format_in,format_not: $format_not,format_not_in: $format_not_in,status_in: $status_in,status_not: $status_not,status_not_in: $status_not_in,episodes_greater: $episodes_greater,episodes_lesser: $episodes_lesser,duration_greater: $duration_greater,duration_lesser: $duration_lesser,chapters_greater: $chapters_greater,chapters_lesser: $chapters_lesser,volumes_greater: $volumes_greater,volumes_lesser: $volumes_lesser,genre_in: $genre_in,genre_not_in: $genre_not_in,tag_in: $tag_in,tag_not_in: $tag_not_in,tagCategory_in: $tagCategory_in,tagCategory_not_in: $tagCategory_not_in,licensedBy_in: $licensedBy_in,averageScore_not: $averageScore_not,averageScore_greater: $averageScore_greater,averageScore_lesser: $averageScore_lesser,popularity_not: $popularity_not,popularity_greater: $popularity_greater,popularity_lesser: $popularity_lesser,source_in: $source_in,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Media Trend query */
    MediaTrend(): FragmentableQueryWithOptionalArgs<IMediaTrendModel, IMediaTrendArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query MediaTrend ($mediaId: Int,$date: Int,$trending: Int,$averageScore: Int,$popularity: Int,$episode: Int,$releasing: Boolean,$mediaId_not: Int,$mediaId_in: [Int]!,$mediaId_not_in: [Int]!,$date_greater: Int,$date_lesser: Int,$trending_greater: Int,$trending_lesser: Int,$trending_not: Int,$averageScore_greater: Int,$averageScore_lesser: Int,$averageScore_not: Int,$popularity_greater: Int,$popularity_lesser: Int,$popularity_not: Int,$episode_greater: Int,$episode_lesser: Int,$episode_not: Int,$sort: [MediaTrendSort]!) {
        MediaTrend(mediaId: $mediaId,date: $date,trending: $trending,averageScore: $averageScore,popularity: $popularity,episode: $episode,releasing: $releasing,mediaId_not: $mediaId_not,mediaId_in: $mediaId_in,mediaId_not_in: $mediaId_not_in,date_greater: $date_greater,date_lesser: $date_lesser,trending_greater: $trending_greater,trending_lesser: $trending_lesser,trending_not: $trending_not,averageScore_greater: $averageScore_greater,averageScore_lesser: $averageScore_lesser,averageScore_not: $averageScore_not,popularity_greater: $popularity_greater,popularity_lesser: $popularity_lesser,popularity_not: $popularity_not,episode_greater: $episode_greater,episode_lesser: $episode_lesser,episode_not: $episode_not,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Airing schedule query */
    AiringSchedule(): FragmentableQueryWithOptionalArgs<
      IAiringScheduleModel,
      IAiringScheduleArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query AiringSchedule ($id: Int,$mediaId: Int,$episode: Int,$airingAt: Int,$notYetAired: Boolean,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$mediaId_not: Int,$mediaId_in: [Int]!,$mediaId_not_in: [Int]!,$episode_not: Int,$episode_in: [Int]!,$episode_not_in: [Int]!,$episode_greater: Int,$episode_lesser: Int,$airingAt_greater: Int,$airingAt_lesser: Int,$sort: [AiringSort]!) {
        AiringSchedule(id: $id,mediaId: $mediaId,episode: $episode,airingAt: $airingAt,notYetAired: $notYetAired,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,mediaId_not: $mediaId_not,mediaId_in: $mediaId_in,mediaId_not_in: $mediaId_not_in,episode_not: $episode_not,episode_in: $episode_in,episode_not_in: $episode_not_in,episode_greater: $episode_greater,episode_lesser: $episode_lesser,airingAt_greater: $airingAt_greater,airingAt_lesser: $airingAt_lesser,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Character query */
    Character(): FragmentableQueryWithOptionalArgs<ICharacterModel, ICharacterArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Character ($id: Int,$search: String,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$sort: [CharacterSort]!) {
        Character(id: $id,search: $search,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Staff query */
    Staff(): FragmentableQueryWithOptionalArgs<IStaffModel, IStaffArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Staff ($id: Int,$search: String,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$sort: [StaffSort]!) {
        Staff(id: $id,search: $search,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Media list query */
    MediaList(): FragmentableQueryWithOptionalArgs<IMediaListModel, IMediaListArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query MediaList ($id: Int,$userId: Int,$userName: String,$type: MediaType,$status: MediaListStatus,$mediaId: Int,$isFollowing: Boolean,$notes: String,$startedAt: FuzzyDateInt,$completedAt: FuzzyDateInt,$compareWithAuthList: Boolean,$userId_in: [Int]!,$status_in: [MediaListStatus]!,$status_not_in: [MediaListStatus]!,$status_not: MediaListStatus,$mediaId_in: [Int]!,$mediaId_not_in: [Int]!,$notes_like: String,$startedAt_greater: FuzzyDateInt,$startedAt_lesser: FuzzyDateInt,$startedAt_like: String,$completedAt_greater: FuzzyDateInt,$completedAt_lesser: FuzzyDateInt,$completedAt_like: String,$sort: [MediaListSort]!) {
        MediaList(id: $id,userId: $userId,userName: $userName,type: $type,status: $status,mediaId: $mediaId,isFollowing: $isFollowing,notes: $notes,startedAt: $startedAt,completedAt: $completedAt,compareWithAuthList: $compareWithAuthList,userId_in: $userId_in,status_in: $status_in,status_not_in: $status_not_in,status_not: $status_not,mediaId_in: $mediaId_in,mediaId_not_in: $mediaId_not_in,notes_like: $notes_like,startedAt_greater: $startedAt_greater,startedAt_lesser: $startedAt_lesser,startedAt_like: $startedAt_like,completedAt_greater: $completedAt_greater,completedAt_lesser: $completedAt_lesser,completedAt_like: $completedAt_like,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Media list collection query, provides list pre-grouped by status & custom lists. User ID and Media Type arguments required. */
    MediaListCollection(): FragmentableQueryWithOptionalArgs<
      IMediaListCollectionModel,
      IMediaListCollectionArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query MediaListCollection ($userId: Int,$userName: String,$type: MediaType,$status: MediaListStatus,$notes: String,$startedAt: FuzzyDateInt,$completedAt: FuzzyDateInt,$forceSingleCompletedList: Boolean,$chunk: Int,$perChunk: Int,$status_in: [MediaListStatus]!,$status_not_in: [MediaListStatus]!,$status_not: MediaListStatus,$notes_like: String,$startedAt_greater: FuzzyDateInt,$startedAt_lesser: FuzzyDateInt,$startedAt_like: String,$completedAt_greater: FuzzyDateInt,$completedAt_lesser: FuzzyDateInt,$completedAt_like: String,$sort: [MediaListSort]!) {
        MediaListCollection(userId: $userId,userName: $userName,type: $type,status: $status,notes: $notes,startedAt: $startedAt,completedAt: $completedAt,forceSingleCompletedList: $forceSingleCompletedList,chunk: $chunk,perChunk: $perChunk,status_in: $status_in,status_not_in: $status_not_in,status_not: $status_not,notes_like: $notes_like,startedAt_greater: $startedAt_greater,startedAt_lesser: $startedAt_lesser,startedAt_like: $startedAt_like,completedAt_greater: $completedAt_greater,completedAt_lesser: $completedAt_lesser,completedAt_like: $completedAt_like,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Collection of all the possible media genres */
    GenreCollection(): AbortableQuery<string[]> {
      const query = sgtsQL\`
      query GenreCollection  {
        GenreCollection
      }\`;
      return abortableQuery(query, false);
    },
    /** Collection of all the possible media tags */
    MediaTagCollection(): FragmentableQueryWithOptionalArgs<
      IMediaTagModel[],
      IMediaTagCollectionArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query MediaTagCollection ($status: Int) {
        MediaTagCollection(status: $status) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** User query */
    User(): FragmentableQueryWithOptionalArgs<IUserModel, IUserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query User ($id: Int,$name: String,$search: String,$sort: [UserSort]!) {
        User(id: $id,name: $name,search: $search,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Get the currently authenticated user */
    Viewer(): FragmentableQuery<IUserModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Viewer  {
        Viewer {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, false);
        }
      };
    },
    /** Notification query */
    Notification(): FragmentableQueryWithOptionalArgs<
      INotificationUnionModel,
      INotificationArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Notification ($type: NotificationType,$resetNotificationCount: Boolean,$type_in: [NotificationType]!) {
        Notification(type: $type,resetNotificationCount: $resetNotificationCount,type_in: $type_in) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Studio query */
    Studio(): FragmentableQueryWithOptionalArgs<IStudioModel, IStudioArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Studio ($id: Int,$search: String,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$sort: [StudioSort]!) {
        Studio(id: $id,search: $search,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Review query */
    Review(): FragmentableQueryWithOptionalArgs<IReviewModel, IReviewArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Review ($id: Int,$mediaId: Int,$userId: Int,$mediaType: MediaType,$sort: [ReviewSort]!) {
        Review(id: $id,mediaId: $mediaId,userId: $userId,mediaType: $mediaType,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Activity query */
    Activity(): FragmentableQueryWithOptionalArgs<IActivityUnionModel, IActivityArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Activity ($id: Int,$userId: Int,$messengerId: Int,$mediaId: Int,$type: ActivityType,$isFollowing: Boolean,$hasReplies: Boolean,$hasRepliesOrTypeText: Boolean,$createdAt: Int,$id_not: Int,$id_in: [Int]!,$id_not_in: [Int]!,$userId_not: Int,$userId_in: [Int]!,$userId_not_in: [Int]!,$messengerId_not: Int,$messengerId_in: [Int]!,$messengerId_not_in: [Int]!,$mediaId_not: Int,$mediaId_in: [Int]!,$mediaId_not_in: [Int]!,$type_not: ActivityType,$type_in: [ActivityType]!,$type_not_in: [ActivityType]!,$createdAt_greater: Int,$createdAt_lesser: Int,$sort: [ActivitySort]!) {
        Activity(id: $id,userId: $userId,messengerId: $messengerId,mediaId: $mediaId,type: $type,isFollowing: $isFollowing,hasReplies: $hasReplies,hasRepliesOrTypeText: $hasRepliesOrTypeText,createdAt: $createdAt,id_not: $id_not,id_in: $id_in,id_not_in: $id_not_in,userId_not: $userId_not,userId_in: $userId_in,userId_not_in: $userId_not_in,messengerId_not: $messengerId_not,messengerId_in: $messengerId_in,messengerId_not_in: $messengerId_not_in,mediaId_not: $mediaId_not,mediaId_in: $mediaId_in,mediaId_not_in: $mediaId_not_in,type_not: $type_not,type_in: $type_in,type_not_in: $type_not_in,createdAt_greater: $createdAt_greater,createdAt_lesser: $createdAt_lesser,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Activity reply query */
    ActivityReply(): FragmentableQueryWithOptionalArgs<
      IActivityReplyModel,
      IActivityReplyArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query ActivityReply ($id: Int,$activityId: Int) {
        ActivityReply(id: $id,activityId: $activityId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Follow query */
    Following(): FragmentableQueryWithArgs<IUserModel, IFollowingArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Following ($userId: Int!,$sort: [UserSort]!) {
        Following(userId: $userId,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Follow query */
    Follower(): FragmentableQueryWithArgs<IUserModel, IFollowerArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Follower ($userId: Int!,$sort: [UserSort]!) {
        Follower(userId: $userId,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Thread query */
    Thread(): FragmentableQueryWithOptionalArgs<IThreadModel, IThreadArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Thread ($id: Int,$userId: Int,$replyUserId: Int,$subscribed: Boolean,$categoryId: Int,$mediaCategoryId: Int,$search: String,$id_in: [Int]!,$sort: [ThreadSort]!) {
        Thread(id: $id,userId: $userId,replyUserId: $replyUserId,subscribed: $subscribed,categoryId: $categoryId,mediaCategoryId: $mediaCategoryId,search: $search,id_in: $id_in,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Comment query */
    ThreadComment(): FragmentableQueryWithOptionalArgs<
      IThreadCommentModel[],
      IThreadCommentArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query ThreadComment ($id: Int,$threadId: Int,$userId: Int,$sort: [ThreadCommentSort]!) {
        ThreadComment(id: $id,threadId: $threadId,userId: $userId,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Recommendation query */
    Recommendation(): FragmentableQueryWithOptionalArgs<
      IRecommendationModel,
      IRecommendationArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Recommendation ($id: Int,$mediaId: Int,$mediaRecommendationId: Int,$userId: Int,$rating: Int,$onList: Boolean,$rating_greater: Int,$rating_lesser: Int,$sort: [RecommendationSort]!) {
        Recommendation(id: $id,mediaId: $mediaId,mediaRecommendationId: $mediaRecommendationId,userId: $userId,rating: $rating,onList: $onList,rating_greater: $rating_greater,rating_lesser: $rating_lesser,sort: $sort) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Like query */
    Like(): FragmentableQueryWithOptionalArgs<IUserModel, ILikeArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Like ($likeableId: Int,$type: LikeableType) {
        Like(likeableId: $likeableId,type: $type) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    /** Provide AniList markdown to be converted to html (Requires auth) */
    Markdown(): FragmentableQueryWithArgs<IParsedMarkdownModel, IMarkdownArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query Markdown ($markdown: String!) {
        Markdown(markdown: $markdown) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    AniChartUser(): FragmentableQuery<IAniChartUserModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query AniChartUser  {
        AniChartUser {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, false);
        }
      };
    },
    /** Site statistics query */
    SiteStatistics(): FragmentableQuery<ISiteStatisticsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query SiteStatistics  {
        SiteStatistics {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, false);
        }
      };
    },
    UpdateUser(): FragmentableMutationWithOptionalArgs<IUserModel, IUpdateUserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation UpdateUser ($about: String,$titleLanguage: UserTitleLanguage,$displayAdultContent: Boolean,$airingNotifications: Boolean,$scoreFormat: ScoreFormat,$rowOrder: String,$profileColor: String,$donatorBadge: String,$notificationOptions: [NotificationOptionInput]!,$animeListOptions: MediaListOptionsInput,$mangaListOptions: MediaListOptionsInput) {
        UpdateUser(about: $about,titleLanguage: $titleLanguage,displayAdultContent: $displayAdultContent,airingNotifications: $airingNotifications,scoreFormat: $scoreFormat,rowOrder: $rowOrder,profileColor: $profileColor,donatorBadge: $donatorBadge,notificationOptions: $notificationOptions,animeListOptions: $animeListOptions,mangaListOptions: $mangaListOptions) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update a media list entry */
    SaveMediaListEntry(): FragmentableMutationWithOptionalArgs<
      IMediaListModel,
      ISaveMediaListEntryArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveMediaListEntry ($id: Int,$mediaId: Int,$status: MediaListStatus,$score: Float,$scoreRaw: Int,$progress: Int,$progressVolumes: Int,$repeat: Int,$priority: Int,$private: Boolean,$notes: String,$hiddenFromStatusLists: Boolean,$customLists: [String]!,$advancedScores: [Float]!,$startedAt: FuzzyDateInput,$completedAt: FuzzyDateInput) {
        SaveMediaListEntry(id: $id,mediaId: $mediaId,status: $status,score: $score,scoreRaw: $scoreRaw,progress: $progress,progressVolumes: $progressVolumes,repeat: $repeat,priority: $priority,private: $private,notes: $notes,hiddenFromStatusLists: $hiddenFromStatusLists,customLists: $customLists,advancedScores: $advancedScores,startedAt: $startedAt,completedAt: $completedAt) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Update multiple media list entries to the same values */
    UpdateMediaListEntries(): FragmentableMutationWithOptionalArgs<
      IMediaListModel[],
      IUpdateMediaListEntriesArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation UpdateMediaListEntries ($status: MediaListStatus,$score: Float,$scoreRaw: Int,$progress: Int,$progressVolumes: Int,$repeat: Int,$priority: Int,$private: Boolean,$notes: String,$hiddenFromStatusLists: Boolean,$advancedScores: [Float]!,$startedAt: FuzzyDateInput,$completedAt: FuzzyDateInput,$ids: [Int]!) {
        UpdateMediaListEntries(status: $status,score: $score,scoreRaw: $scoreRaw,progress: $progress,progressVolumes: $progressVolumes,repeat: $repeat,priority: $priority,private: $private,notes: $notes,hiddenFromStatusLists: $hiddenFromStatusLists,advancedScores: $advancedScores,startedAt: $startedAt,completedAt: $completedAt,ids: $ids) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete a media list entry */
    DeleteMediaListEntry(): FragmentableMutationWithOptionalArgs<
      IDeletedModel,
      IDeleteMediaListEntryArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteMediaListEntry ($id: Int) {
        DeleteMediaListEntry(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete a custom list and remove the list entries from it */
    DeleteCustomList(): FragmentableMutationWithOptionalArgs<
      IDeletedModel,
      IDeleteCustomListArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteCustomList ($customList: String,$type: MediaType) {
        DeleteCustomList(customList: $customList,type: $type) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update text activity for the currently authenticated user */
    SaveTextActivity(): FragmentableMutationWithOptionalArgs<
      ITextActivityModel,
      ISaveTextActivityArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveTextActivity ($id: Int,$text: String,$locked: Boolean) {
        SaveTextActivity(id: $id,text: $text,locked: $locked) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update message activity for the currently authenticated user */
    SaveMessageActivity(): FragmentableMutationWithOptionalArgs<
      IMessageActivityModel,
      ISaveMessageActivityArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveMessageActivity ($id: Int,$message: String,$recipientId: Int,$private: Boolean,$locked: Boolean,$asMod: Boolean) {
        SaveMessageActivity(id: $id,message: $message,recipientId: $recipientId,private: $private,locked: $locked,asMod: $asMod) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Update list activity (Mod Only) */
    SaveListActivity(): FragmentableMutationWithOptionalArgs<
      IListActivityModel,
      ISaveListActivityArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveListActivity ($id: Int,$locked: Boolean) {
        SaveListActivity(id: $id,locked: $locked) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete an activity item of the authenticated users */
    DeleteActivity(): FragmentableMutationWithOptionalArgs<
      IDeletedModel,
      IDeleteActivityArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteActivity ($id: Int) {
        DeleteActivity(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Toggle the subscription of an activity item */
    ToggleActivitySubscription(): FragmentableMutationWithOptionalArgs<
      IActivityUnionModel,
      IToggleActivitySubscriptionArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleActivitySubscription ($activityId: Int,$subscribe: Boolean) {
        ToggleActivitySubscription(activityId: $activityId,subscribe: $subscribe) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update an activity reply */
    SaveActivityReply(): FragmentableMutationWithOptionalArgs<
      IActivityReplyModel,
      ISaveActivityReplyArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveActivityReply ($id: Int,$activityId: Int,$text: String,$asMod: Boolean) {
        SaveActivityReply(id: $id,activityId: $activityId,text: $text,asMod: $asMod) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete an activity reply of the authenticated users */
    DeleteActivityReply(): FragmentableMutationWithOptionalArgs<
      IDeletedModel,
      IDeleteActivityReplyArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteActivityReply ($id: Int) {
        DeleteActivityReply(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Add or remove a like from a likeable type.
                          Returns all the users who liked the same model */
    ToggleLike(): FragmentableMutationWithOptionalArgs<IUserModel[], IToggleLikeArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleLike ($id: Int,$type: LikeableType) {
        ToggleLike(id: $id,type: $type) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Add or remove a like from a likeable type. */
    ToggleLikeV2(): FragmentableMutationWithOptionalArgs<
      ILikeableUnionModel,
      IToggleLikeV2ArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleLikeV2 ($id: Int,$type: LikeableType) {
        ToggleLikeV2(id: $id,type: $type) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Toggle the un/following of a user */
    ToggleFollow(): FragmentableMutationWithOptionalArgs<IUserModel, IToggleFollowArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleFollow ($userId: Int) {
        ToggleFollow(userId: $userId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Favourite or unfavourite an anime, manga, character, staff member, or studio */
    ToggleFavourite(): FragmentableMutationWithOptionalArgs<
      IFavouritesModel,
      IToggleFavouriteArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleFavourite ($animeId: Int,$mangaId: Int,$characterId: Int,$staffId: Int,$studioId: Int) {
        ToggleFavourite(animeId: $animeId,mangaId: $mangaId,characterId: $characterId,staffId: $staffId,studioId: $studioId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Update the order favourites are displayed in */
    UpdateFavouriteOrder(): FragmentableMutationWithOptionalArgs<
      IFavouritesModel,
      IUpdateFavouriteOrderArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation UpdateFavouriteOrder ($animeIds: [Int]!,$mangaIds: [Int]!,$characterIds: [Int]!,$staffIds: [Int]!,$studioIds: [Int]!,$animeOrder: [Int]!,$mangaOrder: [Int]!,$characterOrder: [Int]!,$staffOrder: [Int]!,$studioOrder: [Int]!) {
        UpdateFavouriteOrder(animeIds: $animeIds,mangaIds: $mangaIds,characterIds: $characterIds,staffIds: $staffIds,studioIds: $studioIds,animeOrder: $animeOrder,mangaOrder: $mangaOrder,characterOrder: $characterOrder,staffOrder: $staffOrder,studioOrder: $studioOrder) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update a review */
    SaveReview(): FragmentableMutationWithOptionalArgs<IReviewModel, ISaveReviewArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveReview ($id: Int,$mediaId: Int,$body: String,$summary: String,$score: Int,$private: Boolean) {
        SaveReview(id: $id,mediaId: $mediaId,body: $body,summary: $summary,score: $score,private: $private) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete a review */
    DeleteReview(): FragmentableMutationWithOptionalArgs<IDeletedModel, IDeleteReviewArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteReview ($id: Int) {
        DeleteReview(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Rate a review */
    RateReview(): FragmentableMutationWithOptionalArgs<IReviewModel, IRateReviewArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation RateReview ($reviewId: Int,$rating: ReviewRating) {
        RateReview(reviewId: $reviewId,rating: $rating) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Recommendation a media */
    SaveRecommendation(): FragmentableMutationWithOptionalArgs<
      IRecommendationModel,
      ISaveRecommendationArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveRecommendation ($mediaId: Int,$mediaRecommendationId: Int,$rating: RecommendationRating) {
        SaveRecommendation(mediaId: $mediaId,mediaRecommendationId: $mediaRecommendationId,rating: $rating) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update a forum thread */
    SaveThread(): FragmentableMutationWithOptionalArgs<IThreadModel, ISaveThreadArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveThread ($id: Int,$title: String,$body: String,$categories: [Int]!,$mediaCategories: [Int]!,$sticky: Boolean,$locked: Boolean) {
        SaveThread(id: $id,title: $title,body: $body,categories: $categories,mediaCategories: $mediaCategories,sticky: $sticky,locked: $locked) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete a thread */
    DeleteThread(): FragmentableMutationWithOptionalArgs<IDeletedModel, IDeleteThreadArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteThread ($id: Int) {
        DeleteThread(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Toggle the subscription of a forum thread */
    ToggleThreadSubscription(): FragmentableMutationWithOptionalArgs<
      IThreadModel,
      IToggleThreadSubscriptionArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation ToggleThreadSubscription ($threadId: Int,$subscribe: Boolean) {
        ToggleThreadSubscription(threadId: $threadId,subscribe: $subscribe) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Create or update a thread comment */
    SaveThreadComment(): FragmentableMutationWithOptionalArgs<
      IThreadCommentModel,
      ISaveThreadCommentArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation SaveThreadComment ($id: Int,$threadId: Int,$parentCommentId: Int,$comment: String) {
        SaveThreadComment(id: $id,threadId: $threadId,parentCommentId: $parentCommentId,comment: $comment) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    /** Delete a thread comment */
    DeleteThreadComment(): FragmentableMutationWithOptionalArgs<
      IDeletedModel,
      IDeleteThreadCommentArgsModel
    > {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation DeleteThreadComment ($id: Int) {
        DeleteThreadComment(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    UpdateAniChartSettings(): AbortableMutationWithOptionalArgs<
      string,
      IUpdateAniChartSettingsArgsModel
    > {
      const mutation = sgtsQL\`
      mutation UpdateAniChartSettings ($titleLanguage: String,$outgoingLinkProvider: String,$theme: String,$sort: String) {
        UpdateAniChartSettings(titleLanguage: $titleLanguage,outgoingLinkProvider: $outgoingLinkProvider,theme: $theme,sort: $sort)
      }\`;
      return abortableMutation(mutation, true);
    },
    UpdateAniChartHighlights(): AbortableMutationWithOptionalArgs<
      string,
      IUpdateAniChartHighlightsArgsModel
    > {
      const mutation = sgtsQL\`
      mutation UpdateAniChartHighlights ($highlights: [AniChartHighlightInput]!) {
        UpdateAniChartHighlights(highlights: $highlights)
      }\`;
      return abortableMutation(mutation, true);
    }
  };
};
"
`;

exports[`Test methods generation from different sources Generates types correctly from graphqlZero 1`] = `
"/* eslint-disable */
/* tslint-disable */
// @ts-nocheck
// *******************************************************
// *******************************************************
//
// GENERATED FILE, DO NOT MODIFY
//
// Made by Victor Garcia Â®
//
// https://github.com/victorgarciaesgi
// *******************************************************
// *******************************************************
// ðŸ’™

export type Maybe<T> = T | null;

export interface IQueryModel {
  _?: Maybe<number>;
  albums?: Maybe<IAlbumsPageModel>;
  album?: Maybe<IAlbumModel>;
  comments?: Maybe<ICommentsPageModel>;
  comment?: Maybe<ICommentModel>;
  photos?: Maybe<IPhotosPageModel>;
  photo?: Maybe<IPhotoModel>;
  posts?: Maybe<IPostsPageModel>;
  post?: Maybe<IPostModel>;
  todos?: Maybe<ITodosPageModel>;
  todo?: Maybe<ITodoModel>;
  users?: Maybe<IUsersPageModel>;
  user?: Maybe<IUserModel>;
}

export interface IPageQueryOptionsModel {
  paginate?: Maybe<IPaginateOptionsModel>;
  slice?: Maybe<ISliceOptionsModel>;
  sort?: Maybe<ISortOptionsModel[]>;
  operators?: Maybe<IOperatorOptionsModel[]>;
  search?: Maybe<ISearchOptionsModel>;
}

export interface IPaginateOptionsModel {
  page?: Maybe<number>;
  limit?: Maybe<number>;
}

export interface ISliceOptionsModel {
  start?: Maybe<number>;
  end?: Maybe<number>;
  limit?: Maybe<number>;
}

export interface ISortOptionsModel {
  field?: Maybe<string>;
  order?: Maybe<ISortOrderEnumModel>;
}

export interface IOperatorOptionsModel {
  kind?: Maybe<IOperatorKindEnumModel>;
  field?: Maybe<string>;
  value?: Maybe<string>;
}

export interface ISearchOptionsModel {
  q?: Maybe<string>;
}

export interface IAlbumsPageModel {
  data?: Maybe<IAlbumModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface IAlbumModel {
  id?: Maybe<string>;
  title?: Maybe<string>;
  user?: Maybe<IUserModel>;
  photos?: Maybe<IPhotosPageModel>;
}

export interface IUserModel {
  id?: Maybe<string>;
  name?: Maybe<string>;
  username?: Maybe<string>;
  email?: Maybe<string>;
  address?: Maybe<IAddressModel>;
  phone?: Maybe<string>;
  website?: Maybe<string>;
  company?: Maybe<ICompanyModel>;
  posts?: Maybe<IPostsPageModel>;
  albums?: Maybe<IAlbumsPageModel>;
  todos?: Maybe<ITodosPageModel>;
}

export interface IAddressModel {
  street?: Maybe<string>;
  suite?: Maybe<string>;
  city?: Maybe<string>;
  zipcode?: Maybe<string>;
  geo?: Maybe<IGeoModel>;
}

export interface IGeoModel {
  lat?: Maybe<number>;
  lng?: Maybe<number>;
}

export interface ICompanyModel {
  name?: Maybe<string>;
  catchPhrase?: Maybe<string>;
  bs?: Maybe<string>;
}

export interface IPostsPageModel {
  data?: Maybe<IPostModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface IPostModel {
  id?: Maybe<string>;
  title?: Maybe<string>;
  body?: Maybe<string>;
  user?: Maybe<IUserModel>;
  comments?: Maybe<ICommentsPageModel>;
}

export interface ICommentsPageModel {
  data?: Maybe<ICommentModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface ICommentModel {
  id?: Maybe<string>;
  name?: Maybe<string>;
  email?: Maybe<string>;
  body?: Maybe<string>;
  post?: Maybe<IPostModel>;
}

export interface IPaginationLinksModel {
  first?: Maybe<IPageLimitPairModel>;
  prev?: Maybe<IPageLimitPairModel>;
  next?: Maybe<IPageLimitPairModel>;
  last?: Maybe<IPageLimitPairModel>;
}

export interface IPageLimitPairModel {
  page?: Maybe<number>;
  limit?: Maybe<number>;
}

export interface IPageMetadataModel {
  totalCount?: Maybe<number>;
}

export interface ITodosPageModel {
  data?: Maybe<ITodoModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface ITodoModel {
  id?: Maybe<string>;
  title?: Maybe<string>;
  completed?: Maybe<boolean>;
  user?: Maybe<IUserModel>;
}

export interface IPhotosPageModel {
  data?: Maybe<IPhotoModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface IPhotoModel {
  id?: Maybe<string>;
  title?: Maybe<string>;
  url?: Maybe<string>;
  thumbnailUrl?: Maybe<string>;
  album?: Maybe<IAlbumModel>;
}

export interface IUsersPageModel {
  data?: Maybe<IUserModel[]>;
  links?: Maybe<IPaginationLinksModel>;
  meta?: Maybe<IPageMetadataModel>;
}

export interface IMutationModel {
  _?: Maybe<number>;
  createAlbum?: Maybe<IAlbumModel>;
  updateAlbum?: Maybe<IAlbumModel>;
  deleteAlbum?: Maybe<boolean>;
  createComment?: Maybe<ICommentModel>;
  updateComment?: Maybe<ICommentModel>;
  deleteComment?: Maybe<boolean>;
  createPhoto?: Maybe<IPhotoModel>;
  updatePhoto?: Maybe<IPhotoModel>;
  deletePhoto?: Maybe<boolean>;
  createPost?: Maybe<IPostModel>;
  updatePost?: Maybe<IPostModel>;
  deletePost?: Maybe<boolean>;
  createTodo?: Maybe<ITodoModel>;
  updateTodo?: Maybe<ITodoModel>;
  deleteTodo?: Maybe<boolean>;
  createUser?: Maybe<IUserModel>;
  updateUser?: Maybe<IUserModel>;
  deleteUser?: Maybe<boolean>;
}

export interface ICreateAlbumInputModel {
  title: string;
  userId: string;
}

export interface IUpdateAlbumInputModel {
  title?: Maybe<string>;
  userId?: Maybe<string>;
}

export interface ICreateCommentInputModel {
  name: string;
  email: string;
  body: string;
}

export interface IUpdateCommentInputModel {
  name?: Maybe<string>;
  email?: Maybe<string>;
  body?: Maybe<string>;
}

export interface ICreatePhotoInputModel {
  title: string;
  url: string;
  thumbnailUrl: string;
}

export interface IUpdatePhotoInputModel {
  title?: Maybe<string>;
  url?: Maybe<string>;
  thumbnailUrl?: Maybe<string>;
}

export interface ICreatePostInputModel {
  title: string;
  body: string;
}

export interface IUpdatePostInputModel {
  title?: Maybe<string>;
  body?: Maybe<string>;
}

export interface ICreateTodoInputModel {
  title: string;
  completed: boolean;
}

export interface IUpdateTodoInputModel {
  title?: Maybe<string>;
  completed?: Maybe<boolean>;
}

export interface ICreateUserInputModel {
  name: string;
  username: string;
  email: string;
  address?: Maybe<IAddressInputModel>;
  phone?: Maybe<string>;
  website?: Maybe<string>;
  company?: Maybe<ICompanyInputModel>;
}

export interface IAddressInputModel {
  street?: Maybe<string>;
  suite?: Maybe<string>;
  city?: Maybe<string>;
  zipcode?: Maybe<string>;
  geo?: Maybe<IGeoInputModel>;
}

export interface IGeoInputModel {
  lat?: Maybe<number>;
  lng?: Maybe<number>;
}

export interface ICompanyInputModel {
  name?: Maybe<string>;
  catchPhrase?: Maybe<string>;
  bs?: Maybe<string>;
}

export interface IUpdateUserInputModel {
  name?: Maybe<string>;
  username?: Maybe<string>;
  email?: Maybe<string>;
  address?: Maybe<IAddressInputModel>;
  phone?: Maybe<string>;
  website?: Maybe<string>;
  company?: Maybe<ICompanyInputModel>;
}

export enum ISortOrderEnumModel {
  Asc = 'ASC',
  Desc = 'DESC'
}
export enum IOperatorKindEnumModel {
  Gte = 'GTE',
  Lte = 'LTE',
  Ne = 'NE',
  Like = 'LIKE'
}
export enum ICacheControlScopeModel {
  Public = 'PUBLIC',
  Private = 'PRIVATE'
}
export interface IalbumsModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface IalbumModelArgs {
  id: string;
}

export interface IcommentsModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface IcommentModelArgs {
  id: string;
}

export interface IphotosModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface IphotoModelArgs {
  id: string;
}

export interface IpostsModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface IpostModelArgs {
  id: string;
}

export interface ItodosModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface ItodoModelArgs {
  id: string;
}

export interface IusersModelArgs {
  options?: Maybe<IPageQueryOptionsModel>;
}

export interface IuserModelArgs {
  id: string;
}

export interface IcreateAlbumModelArgs {
  input: ICreateAlbumInputModel;
}

export interface IupdateAlbumModelArgs {
  id: string;
  input: IUpdateAlbumInputModel;
}

export interface IdeleteAlbumModelArgs {
  id: string;
}

export interface IcreateCommentModelArgs {
  input: ICreateCommentInputModel;
}

export interface IupdateCommentModelArgs {
  id: string;
  input: IUpdateCommentInputModel;
}

export interface IdeleteCommentModelArgs {
  id: string;
}

export interface IcreatePhotoModelArgs {
  input: ICreatePhotoInputModel;
}

export interface IupdatePhotoModelArgs {
  id: string;
  input: IUpdatePhotoInputModel;
}

export interface IdeletePhotoModelArgs {
  id: string;
}

export interface IcreatePostModelArgs {
  input: ICreatePostInputModel;
}

export interface IupdatePostModelArgs {
  id: string;
  input: IUpdatePostInputModel;
}

export interface IdeletePostModelArgs {
  id: string;
}

export interface IcreateTodoModelArgs {
  input: ICreateTodoInputModel;
}

export interface IupdateTodoModelArgs {
  id: string;
  input: IUpdateTodoInputModel;
}

export interface IdeleteTodoModelArgs {
  id: string;
}

export interface IcreateUserModelArgs {
  input: ICreateUserInputModel;
}

export interface IupdateUserModelArgs {
  id: string;
  input: IUpdateUserInputModel;
}

export interface IdeleteUserModelArgs {
  id: string;
}

import { OperationDefinitionNode, DocumentNode } from 'graphql';
import sgtsQL from 'graphql-tag';

const guessFragmentType = (fragment: string | DocumentNode) => {
  let isString,
    isFragment = false;
  let fragmentName = '';
  if (typeof fragment === 'string') {
    isString = true;
  } else if (typeof fragment === 'object' && fragment.definitions.length) {
    isFragment = true;
    const definition = fragment.definitions[0];
    if (definition.kind === 'FragmentDefinition') {
      fragmentName = definition.name.value;
    } else {
      console.error(
        \`The argument passed is not a fragment definition, got \${definition.kind} instead\`
      );
      return;
    }
  }
  return { isString, isFragment, fragmentName };
};

import ApolloClient, {
  QueryOptions,
  OperationVariables,
  MutationOptions,
  ObservableQuery
} from 'apollo-client';
import { execute } from 'apollo-link';

export type AbortableQueryWithArgs<T, A> = {
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQueryWithOptionalArgs<T, A> = {
  $fetch(): Promise<T>;
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQuery<T> = {
  $fetch(): Promise<T>;
  $abort(): void;
};
export interface FragmentableQueryWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithArgs<T, A>;
}
export interface FragmentableQueryWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithOptionalArgs<T, A>;
}
export interface FragmentableQuery<T> {
  $fragment(fragment: string | DocumentNode): AbortableQuery<T>;
}

export type AbortableMutationWithArgs<T, A> = {
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutationWithOptionalArgs<T, A> = {
  $post(): Promise<T>;
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutation<T> = {
  $post(): Promise<T>;
  $abort(): void;
};

export interface FragmentableMutationWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithArgs<T, A>;
}
export interface FragmentableMutationWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithOptionalArgs<T, A>;
}
export interface FragmentableMutation<T> {
  $fragment(fragment: string | DocumentNode): AbortableMutation<T>;
}

export const apiProvider = (apolloClient: ApolloClient<any>) => {
  const abortableQuery = <T, A = null>(
    query: DocumentNode,
    args: boolean
  ): A extends null ? AbortableQuery<T> : AbortableQueryWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = query.definitions[0] as OperationDefinitionNode;
    const queryName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $fetch() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[queryName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $fetch
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $fetch
      } as any;
    }
  };
  const abortableMutation = <T, A = null>(
    mutation: DocumentNode,
    args: boolean
  ): AbortableMutationWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = mutation.definitions[0] as OperationDefinitionNode;
    const mutationName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $post() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query: mutation,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[mutationName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $post
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $post
      } as any;
    }
  };

  return {
    albums(): FragmentableQueryWithOptionalArgs<IAlbumsPageModel, IalbumsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query albums ($options: PageQueryOptions) {
        albums(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    album(): FragmentableQueryWithArgs<IAlbumModel, IalbumArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query album ($id: ID!) {
        album(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    comments(): FragmentableQueryWithOptionalArgs<ICommentsPageModel, IcommentsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query comments ($options: PageQueryOptions) {
        comments(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    comment(): FragmentableQueryWithArgs<ICommentModel, IcommentArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query comment ($id: ID!) {
        comment(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    photos(): FragmentableQueryWithOptionalArgs<IPhotosPageModel, IphotosArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query photos ($options: PageQueryOptions) {
        photos(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    photo(): FragmentableQueryWithArgs<IPhotoModel, IphotoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query photo ($id: ID!) {
        photo(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    posts(): FragmentableQueryWithOptionalArgs<IPostsPageModel, IpostsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query posts ($options: PageQueryOptions) {
        posts(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    post(): FragmentableQueryWithArgs<IPostModel, IpostArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query post ($id: ID!) {
        post(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    todos(): FragmentableQueryWithOptionalArgs<ITodosPageModel, ItodosArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query todos ($options: PageQueryOptions) {
        todos(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    todo(): FragmentableQueryWithArgs<ITodoModel, ItodoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query todo ($id: ID!) {
        todo(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    users(): FragmentableQueryWithOptionalArgs<IUsersPageModel, IusersArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query users ($options: PageQueryOptions) {
        users(options: $options) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    user(): FragmentableQueryWithArgs<IUserModel, IuserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query user ($id: ID!) {
        user(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    createAlbum(): FragmentableMutationWithArgs<IAlbumModel, IcreateAlbumArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createAlbum ($input: CreateAlbumInput!) {
        createAlbum(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updateAlbum(): FragmentableMutationWithArgs<IAlbumModel, IupdateAlbumArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updateAlbum ($id: ID!,$input: UpdateAlbumInput!) {
        updateAlbum(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deleteAlbum(): AbortableMutationWithArgs<boolean, IdeleteAlbumArgsModel> {
      const mutation = sgtsQL\`
      mutation deleteAlbum ($id: ID!) {
        deleteAlbum(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    },
    createComment(): FragmentableMutationWithArgs<ICommentModel, IcreateCommentArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createComment ($input: CreateCommentInput!) {
        createComment(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updateComment(): FragmentableMutationWithArgs<ICommentModel, IupdateCommentArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updateComment ($id: ID!,$input: UpdateCommentInput!) {
        updateComment(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deleteComment(): AbortableMutationWithArgs<boolean, IdeleteCommentArgsModel> {
      const mutation = sgtsQL\`
      mutation deleteComment ($id: ID!) {
        deleteComment(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    },
    createPhoto(): FragmentableMutationWithArgs<IPhotoModel, IcreatePhotoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createPhoto ($input: CreatePhotoInput!) {
        createPhoto(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updatePhoto(): FragmentableMutationWithArgs<IPhotoModel, IupdatePhotoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updatePhoto ($id: ID!,$input: UpdatePhotoInput!) {
        updatePhoto(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deletePhoto(): AbortableMutationWithArgs<boolean, IdeletePhotoArgsModel> {
      const mutation = sgtsQL\`
      mutation deletePhoto ($id: ID!) {
        deletePhoto(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    },
    createPost(): FragmentableMutationWithArgs<IPostModel, IcreatePostArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createPost ($input: CreatePostInput!) {
        createPost(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updatePost(): FragmentableMutationWithArgs<IPostModel, IupdatePostArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updatePost ($id: ID!,$input: UpdatePostInput!) {
        updatePost(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deletePost(): AbortableMutationWithArgs<boolean, IdeletePostArgsModel> {
      const mutation = sgtsQL\`
      mutation deletePost ($id: ID!) {
        deletePost(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    },
    createTodo(): FragmentableMutationWithArgs<ITodoModel, IcreateTodoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createTodo ($input: CreateTodoInput!) {
        createTodo(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updateTodo(): FragmentableMutationWithArgs<ITodoModel, IupdateTodoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updateTodo ($id: ID!,$input: UpdateTodoInput!) {
        updateTodo(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deleteTodo(): AbortableMutationWithArgs<boolean, IdeleteTodoArgsModel> {
      const mutation = sgtsQL\`
      mutation deleteTodo ($id: ID!) {
        deleteTodo(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    },
    createUser(): FragmentableMutationWithArgs<IUserModel, IcreateUserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation createUser ($input: CreateUserInput!) {
        createUser(input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    updateUser(): FragmentableMutationWithArgs<IUserModel, IupdateUserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const mutation = sgtsQL\`
      mutation updateUser ($id: ID!,$input: UpdateUserInput!) {
        updateUser(id: $id,input: $input) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableMutation(mutation, true);
        }
      };
    },
    deleteUser(): AbortableMutationWithArgs<boolean, IdeleteUserArgsModel> {
      const mutation = sgtsQL\`
      mutation deleteUser ($id: ID!) {
        deleteUser(id: $id)
      }\`;
      return abortableMutation(mutation, true);
    }
  };
};
"
`;

exports[`Test methods generation from different sources Generates types correctly from jsonplaceholder 1`] = `
"/* eslint-disable */
/* tslint-disable */
// @ts-nocheck
// *******************************************************
// *******************************************************
//
// GENERATED FILE, DO NOT MODIFY
//
// Made by Victor Garcia Â®
//
// https://github.com/victorgarciaesgi
// *******************************************************
// *******************************************************
// ðŸ’™

export type Maybe<T> = T | null;

export interface IRootQueryTypeModel {
  post?: Maybe<IPostModel>;
  posts?: Maybe<IPostModel[]>;
  comment?: Maybe<ICommentModel>;
  comments?: Maybe<ICommentModel[]>;
  album?: Maybe<IAlbumModel>;
  albums?: Maybe<IAlbumModel[]>;
  photo?: Maybe<IPhotoModel>;
  photos?: Maybe<IPhotoModel[]>;
  todo?: Maybe<ITodoModel>;
  todos?: Maybe<ITodoModel[]>;
  user?: Maybe<IUserModel>;
  users?: Maybe<IUserModel[]>;
}

export interface IPostModel {
  user?: Maybe<IUserModel>;
  userId?: Maybe<number>;
  id?: Maybe<number>;
  title?: Maybe<string>;
  body?: Maybe<string>;
}

export interface IUserModel {
  id?: Maybe<number>;
  name?: Maybe<string>;
  username?: Maybe<string>;
  email?: Maybe<string>;
  phone?: Maybe<string>;
  website?: Maybe<string>;
}

export interface ICommentModel {
  post?: Maybe<IPostModel>;
  postId?: Maybe<number>;
  id?: Maybe<number>;
  name?: Maybe<string>;
  email?: Maybe<string>;
  body?: Maybe<string>;
}

export interface IAlbumModel {
  user?: Maybe<IUserModel>;
  userId?: Maybe<number>;
  id?: Maybe<number>;
  title?: Maybe<string>;
}

export interface IPhotoModel {
  album?: Maybe<IAlbumModel>;
  albumId?: Maybe<number>;
  id?: Maybe<number>;
  title?: Maybe<string>;
  url?: Maybe<string>;
  thumbnailUrl?: Maybe<string>;
}

export interface ITodoModel {
  user?: Maybe<IUserModel>;
  userId?: Maybe<number>;
  id?: Maybe<number>;
  title?: Maybe<string>;
  completed?: Maybe<boolean>;
}

export interface IpostModelArgs {
  id?: Maybe<number>;
}

export interface IpostsModelArgs {
  userId?: Maybe<number>;
}

export interface IcommentModelArgs {
  id?: Maybe<number>;
}

export interface IcommentsModelArgs {
  postId?: Maybe<number>;
}

export interface IalbumModelArgs {
  id?: Maybe<number>;
}

export interface IalbumsModelArgs {
  userId?: Maybe<number>;
}

export interface IphotoModelArgs {
  id?: Maybe<number>;
}

export interface IphotosModelArgs {
  albumId?: Maybe<number>;
}

export interface ItodoModelArgs {
  id?: Maybe<number>;
}

export interface ItodosModelArgs {
  userId?: Maybe<number>;
  completed?: Maybe<boolean>;
}

export interface IuserModelArgs {
  id?: Maybe<number>;
}

export interface IusersModelArgs {}

import { OperationDefinitionNode, DocumentNode } from 'graphql';
import sgtsQL from 'graphql-tag';

const guessFragmentType = (fragment: string | DocumentNode) => {
  let isString,
    isFragment = false;
  let fragmentName = '';
  if (typeof fragment === 'string') {
    isString = true;
  } else if (typeof fragment === 'object' && fragment.definitions.length) {
    isFragment = true;
    const definition = fragment.definitions[0];
    if (definition.kind === 'FragmentDefinition') {
      fragmentName = definition.name.value;
    } else {
      console.error(
        \`The argument passed is not a fragment definition, got \${definition.kind} instead\`
      );
      return;
    }
  }
  return { isString, isFragment, fragmentName };
};

import ApolloClient, {
  QueryOptions,
  OperationVariables,
  MutationOptions,
  ObservableQuery
} from 'apollo-client';
import { execute } from 'apollo-link';

export type AbortableQueryWithArgs<T, A> = {
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQueryWithOptionalArgs<T, A> = {
  $fetch(): Promise<T>;
  $args(args: A): AbortableQuery<T>;
  $abort(): void;
};

export type AbortableQuery<T> = {
  $fetch(): Promise<T>;
  $abort(): void;
};
export interface FragmentableQueryWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithArgs<T, A>;
}
export interface FragmentableQueryWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableQueryWithOptionalArgs<T, A>;
}
export interface FragmentableQuery<T> {
  $fragment(fragment: string | DocumentNode): AbortableQuery<T>;
}

export type AbortableMutationWithArgs<T, A> = {
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutationWithOptionalArgs<T, A> = {
  $post(): Promise<T>;
  $args(args: A): AbortableMutation<T>;
  $abort(): void;
};

export type AbortableMutation<T> = {
  $post(): Promise<T>;
  $abort(): void;
};

export interface FragmentableMutationWithArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithArgs<T, A>;
}
export interface FragmentableMutationWithOptionalArgs<T, A> {
  $fragment(fragment: string | DocumentNode): AbortableMutationWithOptionalArgs<T, A>;
}
export interface FragmentableMutation<T> {
  $fragment(fragment: string | DocumentNode): AbortableMutation<T>;
}

export const apiProvider = (apolloClient: ApolloClient<any>) => {
  const abortableQuery = <T, A = null>(
    query: DocumentNode,
    args: boolean
  ): A extends null ? AbortableQuery<T> : AbortableQueryWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = query.definitions[0] as OperationDefinitionNode;
    const queryName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $fetch() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[queryName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $fetch
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $fetch
      } as any;
    }
  };
  const abortableMutation = <T, A = null>(
    mutation: DocumentNode,
    args: boolean
  ): AbortableMutationWithArgs<T, A> => {
    let observableQuery: ZenObservable.Subscription;
    const parsedQuery = mutation.definitions[0] as OperationDefinitionNode;
    const mutationName = parsedQuery.name.value;
    let variables: { [x: string]: any } = {};

    function $abort() {
      if (observableQuery && !observableQuery.closed) {
        observableQuery.unsubscribe();
      }
    }
    async function $post() {
      return new Promise<T>((resolve, reject) => {
        observableQuery = execute(apolloClient.link, {
          query: mutation,
          variables
        }).subscribe({
          next: ({ data, errors }) => {
            if (errors) {
              reject(errors);
            } else {
              resolve(data[mutationName]);
            }
          },
          error: error => reject(error)
        });
      });
    }
    function $args(args) {
      variables = args;
      return {
        $abort,
        $post
      };
    }
    if (args) {
      return {
        $abort,
        $args
      } as any;
    } else {
      return {
        $abort,
        $post
      } as any;
    }
  };

  return {
    post(): FragmentableQueryWithOptionalArgs<IPostModel, IpostArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query post ($id: Int) {
        post(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    posts(): FragmentableQueryWithOptionalArgs<IPostModel[], IpostsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query posts ($userId: Int) {
        posts(userId: $userId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    comment(): FragmentableQueryWithOptionalArgs<ICommentModel, IcommentArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query comment ($id: Int) {
        comment(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    comments(): FragmentableQueryWithOptionalArgs<ICommentModel[], IcommentsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query comments ($postId: Int) {
        comments(postId: $postId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    album(): FragmentableQueryWithOptionalArgs<IAlbumModel, IalbumArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query album ($id: Int) {
        album(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    albums(): FragmentableQueryWithOptionalArgs<IAlbumModel[], IalbumsArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query albums ($userId: Int) {
        albums(userId: $userId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    photo(): FragmentableQueryWithOptionalArgs<IPhotoModel, IphotoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query photo ($id: Int) {
        photo(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    photos(): FragmentableQueryWithOptionalArgs<IPhotoModel[], IphotosArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query photos ($albumId: Int) {
        photos(albumId: $albumId) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    todo(): FragmentableQueryWithOptionalArgs<ITodoModel, ItodoArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query todo ($id: Int) {
        todo(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    todos(): FragmentableQueryWithOptionalArgs<ITodoModel[], ItodosArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query todos ($userId: Int,$completed: Boolean) {
        todos(userId: $userId,completed: $completed) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    user(): FragmentableQueryWithOptionalArgs<IUserModel, IuserArgsModel> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query user ($id: Int) {
        user(id: $id) {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, true);
        }
      };
    },
    users(): FragmentableQuery<IUserModel[]> {
      return {
        $fragment: (fragment: string | DocumentNode) => {
          const { isString, isFragment, fragmentName } = guessFragmentType(fragment);
          const query = sgtsQL\`
      query users  {
        users {
          \${isString ? fragment : '...' + fragmentName}
        }
      } \${isFragment ? fragment : ''}
      \`;

          return abortableQuery(query, false);
        }
      };
    }
  };
};
"
`;
